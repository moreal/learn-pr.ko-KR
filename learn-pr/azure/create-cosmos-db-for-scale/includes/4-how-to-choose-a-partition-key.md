<span data-ttu-id="8f648-101">근무 중인 온라인 판매점이 곧 새로운 지리적 영역으로 확장할 계획입니다.</span><span class="sxs-lookup"><span data-stu-id="8f648-101">The online retailer that you work for plans to expand to a new geographical area soon.</span></span> <span data-ttu-id="8f648-102">이 이동으로 고객 기반 및 트랜잭션 볼륨이 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="8f648-102">This move will increase your customer base and transaction volume.</span></span> <span data-ttu-id="8f648-103">필요할 때마다 확장을 처리할 데이터베이스가 준비되어 있는지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8f648-103">You must ensure that your database is equipped to handle expansion whenever required.</span></span>

<span data-ttu-id="8f648-104">파티션 전략을 사용하면 데이터베이스를 확장해야 할 때 쉽게 확장할 수 있고 효율적인 쿼리와 트랜잭션을 계속 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8f648-104">Having a partition strategy ensures that when your database needs to grow, it can do so easily and continue to perform efficient queries and transactions.</span></span>

## <a name="what-is-a-partition-strategy"></a><span data-ttu-id="8f648-105">파티션 전략이란?</span><span class="sxs-lookup"><span data-stu-id="8f648-105">What is a partition strategy?</span></span>

<span data-ttu-id="8f648-106">단일 서버 또는 단일 파티션에 새 데이터를 계속 추가하면 결국 공간이 부족합니다.</span><span class="sxs-lookup"><span data-stu-id="8f648-106">If you continue to add new data to a single server or a single partition, it will eventually run out of space.</span></span> <span data-ttu-id="8f648-107">이에 대비하려면 강화보다는 **규모 확장** 분할 전략이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="8f648-107">To prepare for this, you need a partitioning strategy to **scale out** instead of up.</span></span> <span data-ttu-id="8f648-108">규모 확장은 수평적 크기 조정이라고도 하고 이를 사용하면 응용 프로그램에 필요할 때 데이터베이스에 더 많은 파티션을 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8f648-108">Scaling out is also called horizontal scaling, and it enables you to add more partitions to your database as your application needs them.</span></span>

<span data-ttu-id="8f648-109">Azure Cosmos DB의 파티션 및 규모 확장 전략은 컬렉션을 만들 때 설정된 값인 파티션 키를 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="8f648-109">The partition and scale-out strategy in Azure Cosmos DB is driven by the partition key, which is a value set when you create a collection.</span></span> <span data-ttu-id="8f648-110">파티션 키가 설정되면 컬렉션을 다시 만들어야 파티션 키를 변경할 수 있으므로, 올바른 파티션 키를 선택하는 것은 개발 프로세스 초기에 결정할 중요한 내용입니다.</span><span class="sxs-lookup"><span data-stu-id="8f648-110">Once the partition key is set, it cannot be changed without recreating the collection, so selecting the right partition key is an important decision to make early in your development process.</span></span>  

<span data-ttu-id="8f648-111">이 단원에서는 시나리오에 적합한 파티션 키를 선택하는 방법을 알아보고 Azure Cosmos DB에서 수행하는 자동 크기 조정을 활용합니다.</span><span class="sxs-lookup"><span data-stu-id="8f648-111">In this unit, you will learn how to choose a partition key that's right for your scenario and will take advantage of the autoscaling that Azure Cosmos DB can do for you.</span></span>

## <a name="partition-key-basics"></a><span data-ttu-id="8f648-112">파티션 키 기본 사항</span><span class="sxs-lookup"><span data-stu-id="8f648-112">Partition key basics</span></span>

<span data-ttu-id="8f648-113">파티션 키는 자주 쿼리되는 데이터베이스의 값을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="8f648-113">A partition key represents a value in your database that's frequently queried.</span></span> <span data-ttu-id="8f648-114">온라인 소매점 시나리오에서 `userID` 또는 `productId` 값을 파티션 키로 사용하는 것이 좋습니다. 이 값은 고유하고 레코드를 조회하는 데 사용할 수 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="8f648-114">In our online retail scenario, using the `userID` or `productId` value as the partition key is a good choice because it will be unique and likely used to lookup records.</span></span> <span data-ttu-id="8f648-115">`userID`를 선택하는 이유는 응용 프로그램에서 사용자의 개인 설정, 쇼핑 카트, 주문 기록 및 프로필 정보 등을 자주 검색해야 하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="8f648-115">`userID` is a good choice, as your application frequently needs to retrieve the personalization settings, shopping cart, order history, and profile information for the user, just to name a few.</span></span> <span data-ttu-id="8f648-116">`productId`도 선택하는 이유는 응용 프로그램에서 재고 수준, 배송 비용, 색상 옵션, 창고 위치 등을 쿼리해야 하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="8f648-116">`productId` is also a good choice, as your application needs to query inventory levels, shipping costs, color options, warehouse locations, and more.</span></span>

<span data-ttu-id="8f648-117">파티션 키는 데이터베이스 전체에 작업을 배포하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="8f648-117">A partition key should aim to distribute operations across the database.</span></span> <span data-ttu-id="8f648-118">핫 파티션을 방지하기 위해 요청을 배포하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="8f648-118">You want to distribute requests to avoid hot partitions.</span></span> <span data-ttu-id="8f648-119">핫 파티션은 다른 파티션보다 많은 요청을 수신하는 단일 파티션으로, 처리량 병목 상태를 일으킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8f648-119">A hot partition is a single partition that receives many more requests than the others, which can create a throughput bottleneck.</span></span> <span data-ttu-id="8f648-120">예를 들어 전자상거래 응용 프로그램의 경우 현재 시간은 파티션 키의 나쁜 선택입니다. 모든 들어오는 데이터가 단일 파티션 키로 이동하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="8f648-120">For example, for your e-commerce application, the current time would be a poor choice of partition key, because all the incoming data would go to a single partition key.</span></span> <span data-ttu-id="8f648-121">`userID` 또는 `productId`를 사용하는 것이 좋습니다. 사이트의 모든 사용자가 거의 동일한 빈도로 쇼핑 카트나 프로필 정보를 추가하고 업데이트할 수 있으므로 모든 사용자 파티션에 읽기 및 쓰기가 분산되기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="8f648-121">`userID` or `productId` would be better, as all the users on your site would likely be adding and updating their shopping cart or profile information at about the same frequency, which distributes the reads and writes across all the user partitions.</span></span> <span data-ttu-id="8f648-122">마찬가지로 제품 데이터의 업데이트도 균일하게 분산될 수 있으므로 파티션 키로 `productId`를 선택하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="8f648-122">Likewise, updates to product data would also likely be evenly distributed, making `productId` a good partition key choice.</span></span>

<span data-ttu-id="8f648-123">각 파티션 키에는 10GB(Azure Cosmos DB에 있는 하나의 물리적 파티션 크기)의 최대 저장소 공간이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8f648-123">Each partition key has a maximum storage space of 10 GB, which is the size of one physical partition in Azure Cosmos DB.</span></span> <span data-ttu-id="8f648-124">따라서 단일 `userID` 또는 `productId` 레코드가 10GB보다 커지면 각 레코드가 더 작아지도록 복합 키를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="8f648-124">So, if your single `userID` or `productId` record is going to be larger than 10 GB, think about using a composite key instead so that each record is smaller.</span></span> <span data-ttu-id="8f648-125">복합 키의 예는 `userID-date`이며 **CustomerName-08072018**과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="8f648-125">An example of a composite key would be `userID-date`, which would look like **CustomerName-08072018**.</span></span> <span data-ttu-id="8f648-126">이 복합 키 방법을 사용하면 사용자가 사이트를 방문한 날마다 새 파티션을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8f648-126">This composite key approach would enable you to create a new partition for each day a user visited the site.</span></span>

## <a name="best-practices"></a><span data-ttu-id="8f648-127">모범 사례</span><span class="sxs-lookup"><span data-stu-id="8f648-127">Best practices</span></span>

<span data-ttu-id="8f648-128">올바른 파티션 키를 결정하려 하는데 솔루션이 분명하지 않은 경우에는 다음과 같은 몇 가지 팁을 고려하세요.</span><span class="sxs-lookup"><span data-stu-id="8f648-128">When you're trying to determine the right partition key and the solution isn't obvious, here are a few tips to keep in mind.</span></span>

- <span data-ttu-id="8f648-129">파티션 키 개수가 너무 많아지는 것을 두려워하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="8f648-129">Don’t be afraid of having too many partition keys.</span></span> <span data-ttu-id="8f648-130">파티션 키가 많을수록 확장성이 커집니다.</span><span class="sxs-lookup"><span data-stu-id="8f648-130">The more partition keys you have, the more scalability you have.</span></span>
- <span data-ttu-id="8f648-131">읽기 작업이 많은 워크로드에 가장 적합한 파티션 키를 결정하려면 사용하려는 상위 3-5개 쿼리를 검토합니다.</span><span class="sxs-lookup"><span data-stu-id="8f648-131">To determine the best partition key for a read-heavy workload, review the top three to five queries you plan on using.</span></span> <span data-ttu-id="8f648-132">WHERE 절에 가장 자주 포함되는 값은 파티션 키의 좋은 후보입니다.</span><span class="sxs-lookup"><span data-stu-id="8f648-132">The value most frequently included in the WHERE clause is a good candidate for the partition key.</span></span>
- <span data-ttu-id="8f648-133">쓰기 작업이 많은 워크로드의 경우 파티션 키가 다중 문서 트랜잭션의 범위이므로 워크로드의 트랜잭션 요구 사항을 이해해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8f648-133">For write-heavy workloads, you'll need to understand the transactional needs of your workload, because the partition key is the scope of multi-document transactions.</span></span>
