<span data-ttu-id="3895b-101">조직의 혁신적인 암 치료를 다루는 뉴스 기사가 방금 게시되었다고 가정합시다.</span><span class="sxs-lookup"><span data-stu-id="3895b-101">Imagine a news story has just been published covering your organization's breakthrough cancer treatment.</span></span> <span data-ttu-id="3895b-102">이 기사는 아주 중요한 획기적인 사건이며, 틀림 없이 웹 사이트에 대규모의 트래픽 유입을 가져오게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-102">This is a terrific milestone, and will undoubtedly bring a large influx of traffic to your website.</span></span> <span data-ttu-id="3895b-103">웹 사이트가 이 트래픽 증가를 처리할 수 있나요, 아니면 부하 때문에 사이트가 느려지거나 응답하지 않게 되나요?</span><span class="sxs-lookup"><span data-stu-id="3895b-103">Will the website handle this traffic increase, or will the load cause the site to be slow or unresponsive?</span></span>

<span data-ttu-id="3895b-104">여기에서 크기 조정 및 최적화 원칙을 사용하여 훌륭한 응용 프로그램 성능을 보장하는 기본 원칙 중 몇 가지를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-104">Here, we'll look at some of the basic principles of ensuring outstanding application performance using scaling and optimization principles.</span></span>

## <a name="what-is-scaling-and-performance-optimization"></a><span data-ttu-id="3895b-105">크기 조정 및 성능 최적화란?</span><span class="sxs-lookup"><span data-stu-id="3895b-105">What is scaling and performance optimization?</span></span>

<span data-ttu-id="3895b-106">크기 조정 및 성능 최적화는 응용 프로그램이 수신하는 요구와 응용 프로그램에 사용할 수 있는 리소스를 일치시키는 방법에 대한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-106">Scaling and performance optimization are about matching the resources available to an application with the demand it is receiving.</span></span> <span data-ttu-id="3895b-107">성능 최적화에는 리소스 크기 조정, 잠재적인 병목 상태 구분 및 최적화, 최고 성능에 대한 응용 프로그램 코드 최적화가 포합됩니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-107">Performance optimization includes scaling resources, identifying and optimizing potential bottlenecks, and optimizing your application code for peak performance.</span></span>

### <a name="scaling"></a><span data-ttu-id="3895b-108">크기 조정</span><span class="sxs-lookup"><span data-stu-id="3895b-108">Scaling</span></span>

<span data-ttu-id="3895b-109">두 가지 방향으로 리소스 계산을 크기 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-109">Compute resources can be scaled in two different directions:</span></span>

* <span data-ttu-id="3895b-110">*강화*는 단일 인스턴스에 더 많은 리소스를 추가하는 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-110">Scaling *up* is the action of adding more resources to a single instance.</span></span>
* <span data-ttu-id="3895b-111">*확장*은 인스턴스를 추가하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-111">Scaling *out* is the addition of instances.</span></span>

![강화 및 확장](../media-draft/scale-up-scale-out.png)

<span data-ttu-id="3895b-113">강화는 단일 인스턴스에 CPU 또는 메모리 같은 더 많은 리소스를 추가하는 것과 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-113">Scaling up is concerned with adding more resources, such as CPU or memory, to a single instance.</span></span> <span data-ttu-id="3895b-114">이 인스턴스는 가상 머신 또는 PaaS 서비스일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-114">This instance could be a virtual machine or a PaaS service.</span></span> <span data-ttu-id="3895b-115">인스턴스에 더 많은 용량을 추가하는 동작은 응용 프로그램에 사용할 수 있는 리소스를 증가시키지만, 추가는 제한적입니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-115">The act of adding more capacity to the instance increases the resources available to your application, but it does come with a limit.</span></span> <span data-ttu-id="3895b-116">가상 머신은 실행하는 호스트의 용량으로 제한되며, 자체 호스트에는 물리적 제한이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-116">Virtual machines are limited to the capacity of the host they run on, and hosts themselves have physical limitations.</span></span> <span data-ttu-id="3895b-117">결과적으로 인스턴스를 강화할 경우 이러한 제한을 실행하여 인스턴스에 리소스를 더 추가하는 기능을 제한할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-117">Eventually, when you scale up an instance, you can run into these limits, restricting your ability to add further resources to the instance.</span></span>

<span data-ttu-id="3895b-118">확장은 서비스에 추가적인 인스턴스를 추가하는 것과 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-118">Scaling out is concerned with adding additional instances to a service.</span></span> <span data-ttu-id="3895b-119">이러한 인스턴스는 가상 머신 또는 PaaS 서비스일 수 있습니다. 그러나 단일 인스턴스를 더 강력하게 만들어 더 많은 용량을 추가하는 대신 전체 총 인스턴스 수를 늘려 용량을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-119">These can be virtual machines or PaaS services, but instead of adding more capacity by making a single instance more powerful, we add capacity by increasing the overall total number of instances.</span></span> <span data-ttu-id="3895b-120">확장의 이점은 아키텍처에 더 많은 머신을 추가할 경우 영구적으로 확장할 수 있다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-120">The advantage of scaling out is that you can conceivably scale out forever if you have more machines to add to the architecture.</span></span> <span data-ttu-id="3895b-121">확장에는 특정 유형의 부하 분산이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-121">Scaling out requires some type of load distribution.</span></span> <span data-ttu-id="3895b-122">이 부하 분산은 사용 가능한 서버에 요청을 분산하는 부하 분산 장치 또는 요청을 보내는 활성 서버를 구분하기 위한 서비스 검색 메커니즘의 형태로 제공될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-122">This could be in the form of a load balancer distributing requests across available servers, or a service discovery mechanism for identifying active servers to send requests to.</span></span>

<span data-ttu-id="3895b-123">두 경우 모두 리소스를 줄여주어 비용 최적화를 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-123">In both cases, resources can be reduced, bringing cost optimization into the picture.</span></span>

### <a name="performance-optimization"></a><span data-ttu-id="3895b-124">성능 최적화</span><span class="sxs-lookup"><span data-stu-id="3895b-124">Performance optimization</span></span>

<span data-ttu-id="3895b-125">성능을 최적화하는 경우 성능이 허용 가능한지 확인하기 위해 네트워크 및 저장소를 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-125">When optimizing for performance, you'll look at network and storage to ensure performance is acceptable.</span></span> <span data-ttu-id="3895b-126">둘 다 응용 프로그램의 응답 시간에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-126">Both can impact the response time of your application.</span></span> <span data-ttu-id="3895b-127">아키텍처에 대한 올바른 네트워킹 및 저장 기술을 선택하면 소비자에게 최상의 환경을 제공하도록 보장하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-127">Selecting the right networking and storage technologies for your architecture will help you ensure you're providing the best experience for your consumers.</span></span>

<span data-ttu-id="3895b-128">성능 최적화에는 또한 응용 프로그램 자체가 작동하는 방법을 이해하는 것도 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-128">Performance optimization will also include understanding how the applications themselves are performing.</span></span> <span data-ttu-id="3895b-129">오류, 잘못 수행된 코드 및 종속 시스템의 병목 현상은 응용 프로그램 성능 관리 도구를 통해 모두 파악할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-129">Errors, poorly performing code, and bottlenecks in dependent systems can all be uncovered through an application performance management tool.</span></span> <span data-ttu-id="3895b-130">대개 이러한 문제는 최종 사용자, 개발자 및 관리자에게 숨기거나 난독 처리될 수 있지만 응용 프로그램의 전반적인 성능에 부정적인 영향을 미칠 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-130">Often, these issues may be hidden or obfuscated for end users, developers, and administrators, but can have adverse impact on the overall performance of your application.</span></span>

## <a name="scalability-and-performance-best-practices"></a><span data-ttu-id="3895b-131">확장성 및 성능 모범 사례</span><span class="sxs-lookup"><span data-stu-id="3895b-131">Scalability and performance best practices</span></span>

<span data-ttu-id="3895b-132">응용 프로그램의 모든 계층을 살펴보고, 응용 프로그램의 성능 병목 상태를 파악하고 수정합니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-132">Look across all layers of your application and identify and remediate performance bottlenecks in your application.</span></span> <span data-ttu-id="3895b-133">이러한 병목 상태는 응용 프로그램에서 또는 데이터베이스에 인덱스를 추가하는 과정에서 메모리가 잘못 처리될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-133">These bottlenecks could be poor memory handling in your application, or even the process of adding indexes into your database.</span></span> <span data-ttu-id="3895b-134">하나의 병목 상태를 완화한 다음, 인식되지 않는 다른 병목 상태를 발견할 수 있으므로 반복적인 프로세스일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-134">It can be an iterative process, as you may relieve one bottleneck and then uncover another that you were unaware of.</span></span>

<span data-ttu-id="3895b-135">아키텍처에서 캐싱을 사용하면 성능을 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-135">Using caching in your architecture can help improve performance.</span></span> <span data-ttu-id="3895b-136">캐싱은 빠른 검색을 위해 자주 사용되는 데이터 또는 자산(웹 페이지, 이미지)을 저장하는 메커니즘입니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-136">Caching is a mechanism to store frequently used data or assets (web pages, images) for faster retrieval.</span></span> <span data-ttu-id="3895b-137">캐싱은 응용 프로그램의 다른 계층에 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-137">Caching can be used at different layers of your application.</span></span> <span data-ttu-id="3895b-138">응용 프로그램 서버 및 데이터베이스 간에 캐싱을 사용하여 데이터 검색 시간을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-138">You can use caching between your application servers and a database, to decrease data retrieval times.</span></span> <span data-ttu-id="3895b-139">또한 최종 사용자 및 웹 서버 사이에 캐싱을 사용하여 고정 콘텐츠를 사용자에게 가깝게 배치하고 최종 사용자에게 웹 페이지를 반환하는 데 걸리는 시간을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-139">You could also use caching between your end users and your web servers, placing static content closer to the user and decreasing the time it takes to return web pages to the end user.</span></span> <span data-ttu-id="3895b-140">이 캐싱은 또한 데이터베이스 또는 웹 서버에서 요청을 오프로딩하는 부차적인 영향을 미쳐 다른 요청에 대한 성능을 향상시킵니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-140">This also has a secondary effect of offloading requests from your database or web servers, increasing the performance for other requests.</span></span>

<span data-ttu-id="3895b-141">여러 작업을 수행하는 하나의 대형 응용 프로그램으로 빌드된 레거시 응용 프로그램은 흔히 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-141">It's not uncommon to see legacy applications built as one large application to do multiple tasks.</span></span> <span data-ttu-id="3895b-142">이러한 아키텍처는 종종 강화에만 제한적이며, 확장은 수행할 수 없습니다. 이러한 유형의 아키텍처에서 응용 프로그램을 현대화하고 서비스를 서로 분리하는 방법을 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-142">These architectures are often limited to only scaling up, and are incapable of scaling out. In these types of architectures, look to modernize your application and decouple services from each other.</span></span> <span data-ttu-id="3895b-143">분리는 응용 프로그램의 주요 기능을 별도 응용 프로그램으로 나누는 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-143">Decoupling is the act of breaking apart the major functions of an application into separate applications.</span></span> <span data-ttu-id="3895b-144">일단 분리되면 각 서비스는 서로 독립적으로 필요에 따라 확장 및 축소될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-144">Once separated, each service could then be scaled-out and scaled-in as needed, independently of each other.</span></span>

<span data-ttu-id="3895b-145">분리와 함께 서비스 간에 메시징 계층을 추가하면 성능에 이점이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-145">Along with decoupling, adding a messaging layer in between services can have a benefit to performance.</span></span> <span data-ttu-id="3895b-146">메시징 계층 추가는 서비스 간 요청에 대한 버퍼를 만들므로 응용 프로그램이 유지할 수 없는 경우에도 요청은 오류 없이 계속 유입될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-146">Adding a messaging layer creates a buffer for requests between the services so that requests can continue to flow in without error if the application can’t keep up.</span></span> <span data-ttu-id="3895b-147">응용 프로그램이 요청을 통해 작동하므로 수신된 순서에 따라 요청에 응답할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-147">As the application works through the requests, they will be answered in the order in which they were received.</span></span>

<span data-ttu-id="3895b-148">아키텍처에 따라 응용 프로그램의 성능을 최적화하기 위한 검색 위치가 다양하게 배열돼 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-148">Depending on the architecture, there's a wide array of places to look to optimize the performance of your application.</span></span> <span data-ttu-id="3895b-149">응용 프로그램의 성능을 평가하여 최적으로 수행되지 않을 수 있는 영역을 검색해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3895b-149">You will need to evaluate the performance of your application, and look for areas that may not be performing optimally.</span></span>
