<span data-ttu-id="05fbd-101">조직의 혁신적인 암 치료를 다루는 뉴스 기사가 방금 게시되었다고 가정합시다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-101">Imagine a news story has just been published covering your organization's breakthrough cancer treatment.</span></span> <span data-ttu-id="05fbd-102">이 기사는 아주 중요한 획기적인 사건이며, 틀림 없이 웹 사이트에 대규모의 트래픽 유입을 가져오게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-102">This is a terrific milestone, and will undoubtedly bring a large influx of traffic to your website.</span></span> <span data-ttu-id="05fbd-103">웹 사이트가 이 트래픽 증가를 처리할 수 있나요, 아니면 부하 때문에 사이트가 느려지거나 응답하지 않게 되나요?</span><span class="sxs-lookup"><span data-stu-id="05fbd-103">Will the website handle this traffic increase, or will the load cause the site to be slow or unresponsive?</span></span>

<span data-ttu-id="05fbd-104">여기에서 크기 조정 및 최적화 원칙을 사용하여 훌륭한 응용 프로그램 성능을 보장하는 기본 원칙 중 몇 가지를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-104">Here, we'll look at some of the basic principles of ensuring outstanding application performance using scaling and optimization principles.</span></span>

## <a name="what-is-scaling-and-performance-optimization"></a><span data-ttu-id="05fbd-105">크기 조정 및 성능 최적화란?</span><span class="sxs-lookup"><span data-stu-id="05fbd-105">What is scaling and performance optimization?</span></span>

<span data-ttu-id="05fbd-106">크기 조정 및 성능 최적화는 응용 프로그램이 수신하는 요구와 응용 프로그램에 사용할 수 있는 리소스를 일치시키는 방법에 대한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-106">Scaling and performance optimization are about matching the resources available to an application with the demand it is receiving.</span></span> <span data-ttu-id="05fbd-107">성능 최적화에는 리소스 크기 조정, 잠재적인 병목 상태 구분 및 최적화, 최고 성능에 대한 응용 프로그램 코드 최적화가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-107">Performance optimization includes scaling resources, identifying and optimizing potential bottlenecks, and optimizing your application code for peak performance.</span></span>

### <a name="scaling"></a><span data-ttu-id="05fbd-108">크기 조정</span><span class="sxs-lookup"><span data-stu-id="05fbd-108">Scaling</span></span>

<span data-ttu-id="05fbd-109">두 가지 방향으로 리소스 계산을 크기 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-109">Compute resources can be scaled in two different directions:</span></span>

* <span data-ttu-id="05fbd-110">*강화*는 단일 인스턴스에 더 많은 리소스를 추가하는 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-110">Scaling *up* is the action of adding more resources to a single instance.</span></span>
* <span data-ttu-id="05fbd-111">*확장*은 인스턴스를 추가하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-111">Scaling *out* is the addition of instances.</span></span>

![성능 용량을 늘리기 위한 가상 머신의 강화 및 확장을 보여주는 일러스트레이션입니다.](../media/scale-up-scale-out.png)

<span data-ttu-id="05fbd-113">강화는 단일 인스턴스에 CPU 또는 메모리 같은 더 많은 리소스를 추가하는 것과 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-113">Scaling up is concerned with adding more resources, such as CPU or memory, to a single instance.</span></span> <span data-ttu-id="05fbd-114">이 인스턴스는 가상 머신 또는 PaaS 서비스일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-114">This instance could be a virtual machine or a PaaS service.</span></span> <span data-ttu-id="05fbd-115">인스턴스에 더 많은 용량을 추가하는 동작은 응용 프로그램에 사용할 수 있는 리소스를 증가시키지만, 추가는 제한적입니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-115">The act of adding more capacity to the instance increases the resources available to your application, but it does come with a limit.</span></span> <span data-ttu-id="05fbd-116">가상 머신은 실행하는 호스트의 용량으로 제한되며, 자체 호스트에는 물리적 제한이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-116">Virtual machines are limited to the capacity of the host they run on, and hosts themselves have physical limitations.</span></span> <span data-ttu-id="05fbd-117">결과적으로 인스턴스를 강화할 경우 이러한 제한을 실행하여 인스턴스에 리소스를 더 추가하는 기능을 제한할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-117">Eventually, when you scale up an instance, you can run into these limits, restricting your ability to add further resources to the instance.</span></span>

<span data-ttu-id="05fbd-118">확장은 서비스에 추가적인 인스턴스를 추가하는 것과 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-118">Scaling out is concerned with adding additional instances to a service.</span></span> <span data-ttu-id="05fbd-119">이러한 인스턴스는 가상 머신 또는 PaaS 서비스일 수 있습니다. 그러나 단일 인스턴스를 더 강력하게 만들어 더 많은 용량을 추가하는 대신 전체 총 인스턴스 수를 늘려 용량을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-119">These can be virtual machines or PaaS services, but instead of adding more capacity by making a single instance more powerful, we add capacity by increasing the overall total number of instances.</span></span> <span data-ttu-id="05fbd-120">확장의 이점은 아키텍처에 더 많은 머신을 추가할 경우 영구적으로 확장할 수 있다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-120">The advantage of scaling out is that you can conceivably scale out forever if you have more machines to add to the architecture.</span></span> <span data-ttu-id="05fbd-121">확장에는 특정 유형의 부하 분산이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-121">Scaling out requires some type of load distribution.</span></span> <span data-ttu-id="05fbd-122">이 부하 분산은 사용 가능한 서버에 요청을 분산하는 부하 분산 장치 또는 요청을 보내는 활성 서버를 구분하기 위한 서비스 검색 메커니즘의 형태로 제공될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-122">This could be in the form of a load balancer distributing requests across available servers, or a service discovery mechanism for identifying active servers to send requests to.</span></span>

<span data-ttu-id="05fbd-123">두 경우 모두 리소스를 줄여주어 비용 최적화를 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-123">In both cases, resources can be reduced, bringing cost optimization into the picture.</span></span>

### <a name="performance-optimization"></a><span data-ttu-id="05fbd-124">성능 최적화</span><span class="sxs-lookup"><span data-stu-id="05fbd-124">Performance optimization</span></span>

<span data-ttu-id="05fbd-125">성능을 최적화하는 경우 성능이 허용 가능한지 확인하기 위해 네트워크 및 저장소를 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-125">When optimizing for performance, you'll look at network and storage to ensure performance is acceptable.</span></span> <span data-ttu-id="05fbd-126">둘 다 응용 프로그램의 응답 시간에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-126">Both can impact the response time of your application.</span></span> <span data-ttu-id="05fbd-127">아키텍처에 대한 올바른 네트워킹 및 저장 기술을 선택하면 소비자에게 최상의 환경을 제공하도록 보장하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-127">Selecting the right networking and storage technologies for your architecture will help you ensure you're providing the best experience for your consumers.</span></span>

<span data-ttu-id="05fbd-128">성능 최적화에는 또한 응용 프로그램 자체가 작동하는 방법을 이해하는 것도 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-128">Performance optimization will also include understanding how the applications themselves are performing.</span></span> <span data-ttu-id="05fbd-129">오류, 잘못 수행된 코드 및 종속 시스템의 병목 현상은 응용 프로그램 성능 관리 도구를 통해 모두 파악할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-129">Errors, poorly performing code, and bottlenecks in dependent systems can all be uncovered through an application performance management tool.</span></span> <span data-ttu-id="05fbd-130">대개 이러한 문제는 최종 사용자, 개발자 및 관리자에게 숨기거나 난독 처리될 수 있지만 응용 프로그램의 전반적인 성능에 부정적인 영향을 미칠 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-130">Often, these issues may be hidden or obfuscated for end users, developers, and administrators, but can have adverse impact on the overall performance of your application.</span></span>

## <a name="scalability-and-performance-patterns-and-practices"></a><span data-ttu-id="05fbd-131">확장성과 성능 패턴 및 사례</span><span class="sxs-lookup"><span data-stu-id="05fbd-131">Scalability and performance patterns and practices</span></span>

<span data-ttu-id="05fbd-132">응용 프로그램의 성능과 확장성을 향상시키기 위해 활용할 수 있는 일부 패턴 및 연습을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-132">Let's take a look at some patterns and practices that can be leveraged to enhance the scalability and performance of your application.</span></span>

### <a name="data-partitioning"></a><span data-ttu-id="05fbd-133">데이터 분할</span><span class="sxs-lookup"><span data-stu-id="05fbd-133">Data partitioning</span></span>

<span data-ttu-id="05fbd-134">대부분의 대규모 솔루션은 데이터를 개별적으로 관리하고 액세스할 수 있는 별도의 파티션으로 나눕니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-134">In many large-scale solutions, data is divided into separate partitions that can be managed and accessed separately.</span></span> <span data-ttu-id="05fbd-135">분할 전략은 부정적인 영향을 최소화하고 이점을 극대화하도록 신중하게 선택해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-135">The partitioning strategy must be chosen carefully to maximize the benefits while minimizing adverse effects.</span></span> <span data-ttu-id="05fbd-136">분할을 통해 확장성을 향상시키고 경합을 줄여 성능을 최적화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-136">Partitioning can help improve scalability, reduce contention, and optimize performance.</span></span>

### <a name="caching"></a><span data-ttu-id="05fbd-137">캐싱</span><span class="sxs-lookup"><span data-stu-id="05fbd-137">Caching</span></span>

<span data-ttu-id="05fbd-138">아키텍처에서 캐싱을 사용하면 성능을 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-138">Use caching in your architecture can help improve performance.</span></span> <span data-ttu-id="05fbd-139">캐싱은 빠른 검색을 위해 자주 사용되는 데이터 또는 자산(웹 페이지, 이미지)을 저장하는 메커니즘입니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-139">Caching is a mechanism to store frequently used data or assets (web pages, images) for faster retrieval.</span></span> <span data-ttu-id="05fbd-140">캐싱은 응용 프로그램의 다른 계층에 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-140">Caching can be used at different layers of your application.</span></span> <span data-ttu-id="05fbd-141">응용 프로그램 서버 및 데이터베이스 간에 캐싱을 사용하여 데이터 검색 시간을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-141">You can use caching between your application servers and a database, to decrease data retrieval times.</span></span> <span data-ttu-id="05fbd-142">또한 최종 사용자 및 웹 서버 사이에 캐싱을 사용하여 고정 콘텐츠를 사용자에게 가깝게 배치하고 최종 사용자에게 웹 페이지를 반환하는 데 걸리는 시간을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-142">You could also use caching between your end users and your web servers, placing static content closer to the user and decreasing the time it takes to return web pages to the end user.</span></span> <span data-ttu-id="05fbd-143">이 캐싱은 또한 데이터베이스 또는 웹 서버에서 요청을 오프로딩하는 부차적인 영향을 미쳐 다른 요청에 대한 성능을 향상시킵니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-143">This also has a secondary effect of offloading requests from your database or web servers, increasing the performance for other requests.</span></span>

### <a name="autoscaling"></a><span data-ttu-id="05fbd-144">자동 크기 조정</span><span class="sxs-lookup"><span data-stu-id="05fbd-144">Autoscaling</span></span>

<span data-ttu-id="05fbd-145">자동 크기 조정은 성능 요구 사항에 맞게 리소스를 동적으로 할당하는 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-145">Autoscaling is the process of dynamically allocating resources to match performance requirements.</span></span> <span data-ttu-id="05fbd-146">작업 용량이 증가하면 응용 프로그램에는 원하는 성능 수준을 유지하고 SLA(서비스 수준 계약)를 만족하기 위해 추가 리소스가 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-146">As the volume of work grows, an application may need additional resources to maintain the desired performance levels and satisfy service-level agreements (SLAs).</span></span> <span data-ttu-id="05fbd-147">수요가 감소하고 추가 리소스가 더 이상 필요 없어지면 비용을 최소화하기 위해 할당을 취소할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-147">As demand slackens and the additional resources are no longer needed, they can be de-allocated to minimize costs.</span></span>

<span data-ttu-id="05fbd-148">자동 크기 조정은 관리 부담을 완화하면서 클라우드에 호스트된 환경의 탄력성을 활용합니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-148">Autoscaling takes advantage of the elasticity of cloud-hosted environments while easing management overhead.</span></span> <span data-ttu-id="05fbd-149">이렇게 하면 운영자가 시스템 성능을 지속적으로 모니터링하고 리소스 추가 또는 제거를 결정할 필요가 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-149">It reduces the need for an operator to continually monitor the performance of a system and make decisions about adding or removing resources.</span></span>

### <a name="decouple-resource-intensive-tasks-as-background-jobs"></a><span data-ttu-id="05fbd-150">리소스 집약적인 작업을 백그라운드 작업으로 분리</span><span class="sxs-lookup"><span data-stu-id="05fbd-150">Decouple resource-intensive tasks as background jobs</span></span>

<span data-ttu-id="05fbd-151">다양한 형식의 응용 프로그램을 사용하려면 UI(사용자 인터페이스)와 독립적으로 실행되는 백그라운드 작업이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-151">Many types of applications require background tasks that run independently of the user interface (UI).</span></span> <span data-ttu-id="05fbd-152">이러한 작업의 예로 배치 작업, 집약적인 처리 작업, 워크플로 등의 장기 실행 프로세스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-152">Examples include batch jobs, intensive processing tasks, and long-running processes such as workflows.</span></span> <span data-ttu-id="05fbd-153">백그라운드 작업은 사용자 조작 없이 실행할 수 있으며, 응용 프로그램은 작업을 시작한 다음 사용자의 조작 요청을 계속 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-153">Background jobs can be executed without requiring user interaction--the application can start the job and then continue to process interactive requests from users.</span></span> <span data-ttu-id="05fbd-154">따라서 응용 프로그램 UI에 대한 부담을 최소화하므로 가용성을 개선하고 대화형 응답 시간을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-154">This can help to minimize the load on the application UI, which can improve availability and reduce interactive response times.</span></span>

### <a name="use-a-messaging-layer-between-services"></a><span data-ttu-id="05fbd-155">서비스 간 메시징 계층 사용</span><span class="sxs-lookup"><span data-stu-id="05fbd-155">Use a messaging layer between services</span></span>

<span data-ttu-id="05fbd-156">서비스 간에 메시징 계층을 추가하면 성능 및 확장성에 이점이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-156">Adding a messaging layer in between services can have a benefit to performance and scalability.</span></span> <span data-ttu-id="05fbd-157">메시징 계층을 추가하면 서비스 간 요청에 대한 버퍼를 만들므로 응용 프로그램이 유지될 수 없는 경우에도 요청은 오류 없이 계속 유입될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-157">Adding a messaging layer creates a buffer for requests between the services so that requests can continue to flow in without error if the application can’t keep up.</span></span> <span data-ttu-id="05fbd-158">응용 프로그램이 요청을 통해 작동하므로 수신된 순서에 따라 요청에 응답할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-158">As the application works through the requests, they will be answered in the order in which they were received.</span></span>

### <a name="implement-scale-units"></a><span data-ttu-id="05fbd-159">배율 단위 구현</span><span class="sxs-lookup"><span data-stu-id="05fbd-159">Implement scale units</span></span>

<span data-ttu-id="05fbd-160">단위로 크기를 조정합니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-160">Scale as a unit.</span></span> <span data-ttu-id="05fbd-161">각 리소스에서 종속 시스템에 크기 조정 작업이 일으킬 수 있는 영향을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-161">For each resource, determine the impact that a scaling activity may have on dependent systems.</span></span> <span data-ttu-id="05fbd-162">이렇게 하면 쉽게 확장 작업을 적용하고, 응용 프로그램에 부정적인 영향이 줄어들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-162">This makes applying scale-out operations easier, and less prone to negative impact on the application.</span></span> <span data-ttu-id="05fbd-163">예를 들어 x개의 웹 및 작업자 역할을 추가하려면 역할에서 생성되는 추가 워크로드를 처리하기 위해 y개의 추가 쿼리 및 z개의 저장소 계정이 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-163">For example, adding x number of web and worker roles might require y number of additional queues and z number of storage accounts to handle the additional workload generated by the roles.</span></span> <span data-ttu-id="05fbd-164">배율 단위는 x개의 웹 및 작업자 역할, y개의 큐 및 z개의 저장소 계정으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-164">A scale unit could consist of x web and worker roles, y queues, and z storage accounts.</span></span> <span data-ttu-id="05fbd-165">하나 이상의 배율 단위를 추가하여 쉽게 확장할 수 있도록 응용 프로그램을 디자인합니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-165">Design the application so that it's easily scaled by adding one or more scale units.</span></span>

### <a name="performance-monitoring"></a><span data-ttu-id="05fbd-166">성능 모니터링</span><span class="sxs-lookup"><span data-stu-id="05fbd-166">Performance monitoring</span></span>

<span data-ttu-id="05fbd-167">클라우드에서 실행되는 분산 응용 프로그램 및 서비스는 특성상, 많은 이동 부분으로 구성되는 복잡한 소프트웨어입니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-167">Distributed applications and services running in the cloud are, by their nature, complex pieces of software that comprise many moving parts.</span></span> <span data-ttu-id="05fbd-168">프로덕션 환경에서는 사용자가 시스템을 활용하는 방식과 리소스 사용률을 추적하고, 시스템의 상태 및 성능을 전반적으로 모니터링할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-168">In a production environment, it's important to be able to track the way in which users utilize your system, trace resource utilization, and generally monitor the health and performance of your system.</span></span> <span data-ttu-id="05fbd-169">이 정보를 진단 보조 기능으로 사용하여 문제를 검색하고 수정할 수 있으며 잠재적 문제를 발견하여 이 문제가 발생하지 않도록 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-169">You can use this information as a diagnostic aid to detect and correct issues, and also to help spot potential problems and prevent them from occurring.</span></span>

<span data-ttu-id="05fbd-170">응용 프로그램의 모든 계층을 살펴보고, 응용 프로그램의 성능 병목 상태를 파악하고 수정합니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-170">Look across all layers of your application and identify and remediate performance bottlenecks in your application.</span></span> <span data-ttu-id="05fbd-171">이러한 병목 상태로 인해 응용 프로그램에서 또는 데이터베이스에 인덱스를 추가하는 과정에서 메모리가 잘못 처리될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-171">These bottlenecks could be poor memory handling in your application, or even the process of adding indexes into your database.</span></span> <span data-ttu-id="05fbd-172">하나의 병목 상태를 완화한 다음, 인식되지 않는 다른 병목 상태를 발견하게 되면 반복적인 프로세스일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-172">It may be an iterative process as you relieve one bottleneck and then uncover another that you were unaware of.</span></span>

<span data-ttu-id="05fbd-173">성능 모니터링에 대한 철저한 접근법을 사용하여 아키텍처에서 활용할 수 있는 패턴 및 사례 형식을 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05fbd-173">With a thorough approach to performance monitoring, you'll be able to determine what types of patterns and practices your architecture will benefit from.</span></span>