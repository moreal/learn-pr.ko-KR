마지막으로 연습에서는 Azure Cosmos DB 데이터베이스의 책갈피 조회 하는 시나리오를 구현 했습니다. 책갈피 컬렉션에서 데이터를 읽이 입력된 바인딩을 구성 했습니다. 하지만 데이터를 읽기만 하는 것은 지루한 작업을 더 수행 하겠습니다. 쓰기를 포함 하는 시나리오를 확장 해 보겠습니다. 다음 순서도를 것이 좋습니다.

![백 엔드는 Cosmos DB에서 책갈피를 추가 하는 프로세스를 보여 주는 흐름 다이어그램](../media-draft/add-bookmark-flow-small.png)

이 시나리오에서는 책갈피 목록에 추가 요청을 받게 됩니다. 원하는 키 또는 ID, 책갈피 URL과 함께 요청을 전달합니다. 순서도에서 보듯이 응답을 드립니다 오류가 발생 하 여이 백 엔드에 키가 이미 있는 경우.

우리에 게 전달 된 키가 있으면 *되지* , 새 책갈피에 추가 데이터베이스입니다. 거기에서 중지할 수 있지만 보겠습니다 좀 더 수행 했습니다.

순서도의 다른 단계를 확인할 수 있습니다. 지금 처리 측면에서 수신 하는 데이터를 사용 하 여 거의 수행 하지 않은 것입니다. 데이터베이스에 접수 이동 합니다. 그러나 실제 솔루션에서는 가능성이 아마도 특정 방식으로 데이터 처리는 것입니다. 동일한 기능을 하지만이 랩에서 다른 구성 요소 또는 비즈니스 논리의 부분에 추가 처리를 오프 로드 하는 패턴을 살펴보겠습니다 모든 처리를 수행 하도록 결정할 수 있습니다.

책갈피 시나리오의 작업 오프 로딩이 좋은 예가 될 수 있습니다 무엇입니까? 잘 경우 새 책갈피에 보내는 QR 코드 생성은? 해당 서비스는 차례로 URL에 대 한 QR 코드를 생성, blob storage에 이미지를 저장 하며 책갈피 컬렉션에 있는 항목에 다시 qr 이미지의 주소를 추가 합니다. Qr 이미지를 생성 하는 서비스를 호출 하는 것은 시간이 많이 걸립니다 따라서 대신 결과 기다릴 것 보다는 함수에 전달 하 고이 비동기적으로 처리 하도록 합니다.

Azure Functions에서는 서로 다른 통합 원본 입력된 바인딩은으로 쉽게 데이터를 데이터 원본에 쓸 수에 대 한 출력 바인딩 템플릿 집합을 수도 있습니다. 출력 바인딩은에 구성 된 합니다 *function.json* 파일입니다.  이 연습에서 살펴보겠지만 여러 데이터 원본 및 서비스를 사용 하 여 함수를 구성할 수 있습니다.

> [!IMPORTANT]
> 이 연습은 마지막 단위의 연습, 즉, 동일한 Azure Cosmos DB 데이터베이스 및 입력된 바인딩을 사용 합니다. 에 해당 장치를 통해 작업 하지 않은 경우이 실험을 진행 하기 전에 이렇게 하는 것이 좋습니다.

## <a name="create-an-httptriggered-function"></a>HTTP_triggered 함수 만들기

1. [Azure Portal](https://portal.azure.com/?azure-portal=true)에 로그인합니다.

2. Azure portal에서이 모듈에서 만든 함수 앱으로 이동 합니다.

3. 함수 앱을 확장 하 고 함수 컬렉션을 마우스로 추가 선택 (**+**) 옆에 단추 **함수**합니다. 이 작업에는 함수 만들기 프로세스를 시작합니다. 다음 애니메이션은이 작업을 보여 줍니다.

![사용자가 함수 메뉴 항목을 마우스로 가리킬 때 표시 되는 더하기의 애니메이션.](../media-draft/func-app-plus-hover-small.gif)

4. 페이지는 현재 지원 되는 트리거 집합을 보여줍니다. 선택 **HTTP 트리거**에 다음 스크린샷에 첫 번째 항목입니다.

![맨 먼저 표시 TTP 트리거를 사용 하 여 트리거 템플릿 선택 UI의 부분 스크린 샷 왼쪽 이미지입니다.](../media-draft/trigger-templates-small.PNG)

5. 입력 합니다 **새 함수** 다음 값을 사용 하 여 오른쪽에 나타나는 대화 상자.

|필드  |값  |
|---------|---------|
|언어     | **JavaScript**        |
|이름     |   [!INCLUDE [func-name-add](./func-name-add.md)]     |
| 권한 부여 수준 | **Function** |

5. 선택 **Create** index.js 파일을 코드 편집기에서 열리고 기본 구현 된 HTTP 트리거 함수는이 함수를 만듭니다.

이 연습에서는 수 작업 속도 사용 하 여 합니다 *코드* 하 고 *구성* 시작 지점으로 이전 장치에서.

6. Index.js에서 모든 코드를 다음 코드 조각 및 클릭에서 코드로 바꿉니다 **저장할** 이 변경 내용을 저장 합니다. 

[!code-javascript[](../code/find-bookmark-single.js)]

이 코드에서는 친숙 한을 하는 경우 구현 이기 때문에 우리 [!INCLUDE [func-name-find](./func-name-find.md)] 함수입니다. 예상한 것 처럼 함수는 동일한 바인딩을 정의 될 때까지 작동 하지 않습니다.  

7. 엽니다는 *function.json* 에서 파일을 [!INCLUDE [func-name-find](./func-name-find.md)] 함수. 열어 찾을 수 있습니다 합니다 **파일을 볼** 코드 편집기의 오른쪽에 메뉴.

8. 이 파일의 전체 내용을 복사 합니다.

9. 엽니다는 *function.json* 에서 파일을 [!INCLUDE [func-name-add](./func-name-add.md)] 함수.

10. 복사한 내용을이 파일의 내용을 바꿉니다 합니다 *function.json* 와 연결 된 파일을 [!INCLUDE [func-name-find](./func-name-find.md)] 함수입니다. 완료 되 면 function.json 다음 JSON을 포함 해야 합니다.

```json
{
  "bindings": [
    {
      "authLevel": "function",
      "type": "httpTrigger",
      "direction": "in",
      "name": "req"
    },
    {
      "type": "http",
      "direction": "out",
      "name": "res"
    },
    {
      "type": "documentDB",
      "name": "bookmark",
      "databaseName": "func-io-learn-db",
      "collectionName": "Bookmarks",
      "connection": "unit3test_DOCUMENTDB",
      "direction": "in",
      "id": "{id}"
    }
  ],
  "disabled": false
}
```

11. 해야 **저장할** 모든 변경 내용이 있습니다.

이전 단계에서 구성한 바인딩 우리의 새 함수에 대 한 다른 바인딩 정의 복사 하 여 합니다. 수, 물론, UI 통해 새 바인딩을 생성 하지만이 대신 사용할 수 있는지를 이해 하는 것이 좋습니다.

## <a name="try-it-out"></a>체험

1. 일반적으로 클릭 **<> / 함수 URL 가져오기** 오른쪽 위에 있는 선택 **기본값 (함수 키)** 를 클릭 하 고 **복사** URL의 함수를 복사 하 여 합니다.

2. 브라우저의 주소 표시줄에 복사해 둔 함수 URL을 붙여넣습니다. `&id=docs` 쿼리 문자열을 이 URL의 마지막에 추가하고 키보드에서 `Enter` 키를 눌러 요청을 실행합니다. 모든 원활 하 게, 해당 리소스에 대 한 URL을 포함 하는 응답을 표시 합니다.

따라서 여기가 어디에? 물론 지금에서는 실제로 복제 한 이전 랩에서 했습니다. 하지만 괜찮습니다. 마지막 랩에이 대이 한 시작 점으로 사용할 했던를 복사 하는 것입니다. 에서는 작업 하 게 새로운 기능 다음으로, 즉, 데이터베이스에 작성 합니다. 이 위해 필요는 *출력 바인딩을*합니다.

## <a name="define-azure-cosmos-db-output-binding"></a>정의 Azure Cosmos DB 출력 바인딩

대신 사용자 인터페이스를 통해 이동 하 여 새 출력 바인딩을 정의 만들어이 바인딩 구성 파일을 업데이트 하 여 *function.json*, 직접. 

1. 열기는 **function.json** 에서 선택 하 여 편집기에서이 함수에 대 한 파일을 **파일을 볼** 목록입니다.

2. 이름 사용 하 여 바인딩을 복사 `bookmark` 해당 파일에 있습니다.

3. 닫는 중괄호를 닫는 대괄호 앞 바로 뒤에 커서를 놓습니다. 쉼표를 추가 `,` 바인딩의 복사본을 붙여 여기 있습니다. 프로그램 *function.json* 구성 다음과 같아집니다.

[!code-json[](../code/config-new-entry.json?highlight=22-31)]

4. 다음 변경 내용으로 붙여 넣어도 바인딩을 편집 합니다.


|자산   |이전 값  |새 값  |
|---------|---------|---------|
|이름     |   책갈피      |  **newbookmark**       |
|direction     |   in      |   **out**      |
|id     |      {id}   |   **이 속성을 삭제 합니다. 출력 바인딩에 대 한 존재 하지 않습니다.**      |

이러한 변경 하면 결국 다음 JSON 처럼 보이는 파일입니다.

[!code-json[](../code/config-q-complete.json?highlight=22-30)]

단순히 구성 파일에서 직접 바인딩을 만들 수 있는 방법의 데모 했습니다. 이 예제에서는 편이에서는 다시 사용 하는 다른 바인딩 속성 즉, 때문에 합니다 `databaseName`, `collectionName` 및 `connection` 는 이미 구성 했습니다는 Cosmos db 입력 바인딩.

> [!NOTE]
> 실제 값 `connection` 위의 JSON 파일 연결이 만들어질 때 지정 된 이름이 됩니다.

코드를 업데이트 하기 전에 큐에 메시지를 게시할 수 있게 해 주는 자세한 바인딩이 두 개를 추가 해 보겠습니다.

## <a name="define-azure-queue-storage-output-binding"></a>정의 Azure Queue Storage 출력 바인딩

Azure Queue storage는 액세스할 수 있는에서 아무 곳 이나 전 세계에서 메시지를 저장 하기 위한 서비스입니다. 단일 메시지에는 최대 64KB 일 수 있습니다 하 고 큐에 메시지 정의 되어 있는 저장소 계정의 총 용량 제한까지 수백만 포함 될 수 있습니다. 다음 다이어그램은 시나리오에는 큐를 사용 하는 방법을 개략적으로 보여줍니다.

![저장소 큐의 개념과 함수와 푸시 및 팝 큐에 메시지를 보여 주는 다이어그램입니다.](../media-draft/q-logical-small.png)

여기서 볼 수 있는 하는 새 함수를 [!INCLUDE [func-name-add](./func-name-add.md)], 큐에 메시지를 추가 합니다. 예를 들어 가상의 함수를 다른 함수를 호출 *gen-qr 코드*는 동일한 큐에서 메시지를 표시 하 고 요청을 처리 합니다.  에서는 쓰므로 또는 *푸시*에서 큐에 메시지를 [!INCLUDE [func-name-add](./func-name-add.md)]를 솔루션에 새 출력 바인딩을 추가 합니다. UI 통해 바인딩을이 시간을 만들어 보겠습니다.

1. 선택 **통합** 통합 탭을 열려면 왼쪽 메뉴의 함수입니다.

2. 선택 **+ 새 출력** 아래의 합니다 **출력** 열입니다. 모든 가능한 출력 바인딩 형식 목록이 표시 됩니다.

3. 클릭할 **Azure Queue Storage** 목록에서 다음을 **선택** 단추입니다. 이 작업에는 Azure Queue Storage 출력 구성 페이지가 열립니다.

다음으로, 저장소 계정 연결을 설정 했습니다. 큐 호스팅될입니다.

4. 명명 된 필드에 **Storage 계정 연결** 이 페이지에서 클릭 *새* 빈 필드의 오른쪽에 있습니다. 열립니다는 **저장소 계정** 선택 대화 상자. 

5. 이 모듈을 시작 하 고 함수 앱을 생성, 해당 시간에 저장소 계정은 만들었습니다. 이 대화 상자에 나열 됩니다, 따라서 계속 해 서 고 선택 합니다. 합니다 **Storage 계정 연결** 필드는 연결의 이름으로 채워집니다. 연결 문자열 값을 확인 하려는 경우 클릭할 **값이 표시**합니다.

6. 해당 기본값을 사용 하 여이 페이지에서 다른 모든 필드 상태로 두면 없습니다, 하지만 다음 속성에 더 많은 의미를 대여할을 변경해 보겠습니다.


|자산  |이전 값  |새 값  | 설명 |
|---------|---------|---------|---------|
|큐 이름     |    outqueue     |  **bookmarks-post-process**      | 이 이름은 배치 하는 큐의 책갈피에 처리할 수 있도록 추가로 다른 함수에 의해 합니다. |
| 메시지 매개 변수 이름    |  outputQueueItem       |   **newmessage**      | 코드에서 사용 해야 하는 바인딩 속성입니다. |


7. 클릭 해야 **저장할** 변경 내용을 저장 합니다.

## <a name="update-function-implementation"></a>업데이트 함수 구현

이제이 바인딩 설정 모두를 [!INCLUDE [func-name-add](./func-name-add.md)] 함수입니다. 이 함수에서 사용 하는 차례입니다.

1.  이 함수를 클릭 [!INCLUDE [func-name-add](./func-name-add.md)]를 열어 *index.js* 코드 편집기에서.

2. Index.js에서 모든 코드를 다음 코드 조각에서 코드를 바꿉니다.

[!code-javascript[](../code/add-bookmark.js)]

보겠습니다 분석이이 코드의 용도입니다.

* 이 함수는 데이터를 변경 하므로 HTTP 요청을 POST이 고 책갈피 요청 본문의 일부가 되려면 예정입니다.
* 이 Cosmos DB 입력된 바인딩 문서 또는 책갈피를 검색 하려고 시도 사용 하는 `id` 수신 하는 합니다. 항목을 찾으면를 `bookmark` 개체 설정이 적용 됩니다. `if(bookmark)` 조건 항목을 찾을 수 있는지 여부를 확인 합니다.
* 설정 작업은 데이터베이스에 추가 된 `context.bindings.newbookmark` JSON 문자열로 만든 새 책갈피 항목에 대 한 바인딩 매개 변수입니다.
* 로 설정 하기만 하면 되는 큐에 메시지 게시를 `context.bindings.newmessage parameter`입니다.

> [!NOTE]
> 수행한 유일한 태스크 큐 바인딩을 만드는 경우 에서는 만들어지지 큐 명시적으로 합니다. 바인딩의 기능을 살펴보기 됩니다! 다음 설명선 라는 큐 존재 하지 않는 경우를 자동으로 생성 됩니다.

![호출 하는 스크린 샷 큐 자동-만들어질 수 있습니다.](../media-draft/q-auto-create-small.png)

따라서 이것이-다음 섹션에서 실행 중인 작업을 확인해 보겠습니다.

## <a name="try-it-out"></a>체험

복수의 출력 바인딩이 만들었으므로 테스트 됩니다 조금 더 까다롭습니다. 반면 이전 labs에서 콘텐츠를 HTTP 요청 및 쿼리 문자열을 전송 하 여 테스트 된,이 이번 HTTP Post를 수행 하고자 합니다. 또한 여부 메시지 작업을 큐에 확인 해야 합니다.

1.  이 함수를 사용 하 여 [!INCLUDE [func-name-add](./func-name-add.md)], 함수 앱 포털에서 선택한 테스트 메뉴 항목 맨 왼쪽에 있는 확장을 클릭 합니다.

2. 선택 된 **테스트** 메뉴 항목을 열고 테스트 패널에 있는지 확인 합니다. 다음 스크린샷은 처럼 보여야 합니다. 

![테스트 창 함수를 보여 주는 스크린 샷 확장 합니다.](../media-draft/test-panel-open-small.png)

> [!IMPORTANT]
> 했는지 **POST** HTTP 방법 드롭다운에서 선택 합니다.

3. 다음 JSON 페이로드를 사용 하 여 요청 본문의 콘텐츠를 대체 합니다.

```json
  {
      "id": "docs",
      "url": "https://docs.microsoft.com/azure"
  }
  ```

4. 클릭 **실행** 테스트 패널의 맨 아래에 있습니다. 

5. 있는지 확인 합니다 *출력* 창에 표시 된 "책갈피 이미 있습니다." 다음 다이어그램에 나와 있는 것 처럼 메시지입니다. 

![테스트 패널 및 실패 한 테스트의 결과 보여주는 스크린샷.](../media-draft/test-exists-small.png)

6. 이제 다음 페이로드를 사용 하 여 요청 본문을 대체 합니다. 

```json
  {
      "id": "github",
      "URL": "https://www.github.com"
  }
  ```
7. 클릭 **실행** 테스트 패널의 맨 아래에 있습니다.

8. 이 확인 *출력* 상자는 다음 다이어그램에 나와 있는 것 처럼 "책갈피 추가" 메시지를 표시 합니다.

![패널 테스트 및 성공적인 테스트의 결과 보여주는 스크린샷.](../media-draft/test-success-small.png)

축하합니다. [!INCLUDE [func-name-add](./func-name-add.md)] 를 정상적으로 작동 하지만 했습니다. 코드에서 해당 큐 작업에 대 한 새로운? 물론 살펴보겠습니다 무언가 큐에 작성 한 경우.

### <a name="verify-that-a-message-is-written-to-our-queue"></a>메시지 큐에 기록 됩니다 있는지 확인

Azure Queue Storage 큐는 저장소 계정에서 호스트 됩니다. 출력 바인딩을 만들 때 이미이 연습에서 저장소 계정을 선택 합니다. 

1. Azure portal에서 기본 검색 상자에 입력 *저장소 계정* 검색 결과에서 선택 하 고 **저장소 계정** 아래 합니다 *Services* 범주입니다. 이 다음 스크린샷에 설명 되어 있습니다. 

![기본 검색 상자에 저장소 계정에 대 한 검색 결과 보여 주는 스크린샷.](../media-draft/search-for-sa-small.png)

2. 반환 되는 저장소 계정 목록을 만드는 데 사용한 저장소 계정을 선택 합니다 **newmessage** 출력 바인딩. 주 창에 표시 하는 저장소 계정 설정 포털입니다.

3. 선택 된 **큐** 서비스 목록에서 항목입니다. 이이 저장소 계정에서 호스트 하는 큐의 목록을 표시 합니다. 있는지 확인 합니다 **책갈피-post-프로세스** 다음 스크린샷에 표시 된 대로 큐가 있는 합니다.

![이 저장소 계정에서 호스트 하는 큐의 목록에서 큐를 보여 주는 스크린샷](../media-draft/q-in-list-small.png)

4. 클릭할 **책갈피-post-프로세스** 큐를 열 수 있습니다. 큐에 있는 메시지 목록에 표시 됩니다. 계획에 따라 한다면 데이터베이스에 책갈피를 추가 했을 때에서는 게시 된 메시지 큐에 있어야 하 고 다음 항목은 같습니다. 

![큐에서 메시지를 보여 주는 스크린샷](../media-draft/message-in-q-small.png)

이 예에서 볼 수 있습니다 메시지는 고유한 ID가 올바른지와 **메시지 텍스트** 필드에이 책갈피를 JSON 문자열 형식으로 표시 됩니다.

5. 새 id/url 집합을 사용 하 여 테스트 패널에 있는 요청 본문을 변경 하 고 함수를 실행 하 여 추가 함수를 테스트할 수 있습니다. 이 큐에 도착 한 메시지를 더 보려면 시청 하세요. 또한 확인 하려면 데이터베이스에서 새 항목이 추가 되었습니다. 

이 랩에서으로 확장 했습니다 바인딩에 대 한 지식을 출력 바인딩을 Azure Cosmos DB에 데이터를 작성 합니다. 발전 하 고 Azure 큐에 메시지를 게시 하려면 다른 출력 바인딩을 추가 합니다. 이 모양 지정 및 다양 한 대상에 들어오는 소스에서 데이터를 이동 하는 데 바인딩의 진정한 능력을 보여 줍니다. 데이터베이스 코드를 작성 또는 직접 연결 문자열을 관리 해야 하지 않은 것입니다. 바인딩을 구성한 대신 선언적으로 하 고 연결 보안,이 함수를 크기 조정 및 연결을 크기 조정 관리 플랫폼입니다.