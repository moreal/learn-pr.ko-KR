<span data-ttu-id="99855-101">스포츠 웹 사이트의 백그라운드에 있는 데이터베이스는 쿼리를 실행하여 데이터를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="99855-101">Behind your sports website is a database, which returns data by executing queries.</span></span> <span data-ttu-id="99855-102">그러나 특히 대규모 스포츠 이벤트 중에 부하가 높을 경우 성능이 저하됩니다.</span><span class="sxs-lookup"><span data-stu-id="99855-102">However, performance slows down when the load is high, particularly during large sporting events.</span></span> <span data-ttu-id="99855-103">호스트형 환경에서 리소스 사용량 증가는 비용 증가로 이어집니다.</span><span class="sxs-lookup"><span data-stu-id="99855-103">In hosted environments, increased resource usage translates into higher costs.</span></span> <span data-ttu-id="99855-104">데이터를 캐시하면 웹 사이트가 제대로 작동하고 경제적으로 운영됩니다.</span><span class="sxs-lookup"><span data-stu-id="99855-104">Caching data ensures your website will perform well and run economically.</span></span>

## <a name="what-is-caching"></a><span data-ttu-id="99855-105">캐싱이란?</span><span class="sxs-lookup"><span data-stu-id="99855-105">What is caching?</span></span>

<span data-ttu-id="99855-106">캐싱은 자주 액세스하는 데이터를 해당 데이터를 소비하는 응용 프로그램과 가까운 메모리에 저장하는 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="99855-106">Caching is the act of storing frequently-accessed data in memory that is very close to the application that consumes the data.</span></span> <span data-ttu-id="99855-107">캐싱은 성능을 높이고 서버의 부하를 줄이는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="99855-107">Caching is used to increase performance and reduce the load on your servers.</span></span> <span data-ttu-id="99855-108">여기서는 Redis를 사용하여 대기 시간을 단축하고 성능을 향상할 수 있는 메모리 내 캐시를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="99855-108">We use Redis to create an in-memory cache that can provide excellent latency and potentially improve performance.</span></span>

## <a name="what-is-a-redis-cache"></a><span data-ttu-id="99855-109">Redis 캐시란?</span><span class="sxs-lookup"><span data-stu-id="99855-109">What is a Redis cache?</span></span>

<span data-ttu-id="99855-110">Redis(**RE**mote **DI**ctionary **S**erver) 캐시는 오픈 소스의 메모리 내 키 값 쌍 저장소입니다.</span><span class="sxs-lookup"><span data-stu-id="99855-110">Redis (**RE**mote **DI**ctionary **S**erver) cache is an open-source, in-memory key value pair store.</span></span> <span data-ttu-id="99855-111">빠르고 문자열, 해시, 집합 등의 공통 데이터 형식을 저장 및 조작할 수 있기 때문에 널리 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="99855-111">It's popular because it's fast and can store and manipulate common data types such as strings, hashes, and sets.</span></span> <span data-ttu-id="99855-112">또한 Python, C, C++, C#, Java, JavaScript 등의 여러 언어를 지원하므로 개발자 친화적인 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="99855-112">It's also considered developer friendly as it supports multiple languages such as Python, C, C++, C#, Java, and JavaScript among others.</span></span>

## <a name="what-is-azure-redis-cache"></a><span data-ttu-id="99855-113">Azure Redis Cache란?</span><span class="sxs-lookup"><span data-stu-id="99855-113">What is Azure Redis Cache?</span></span>

<span data-ttu-id="99855-114">Microsoft Azure Redis Cache는 많이 사용되는 오픈 소스 Redis Cache를 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="99855-114">Microsoft Azure Redis Cache is based on the popular open-source Redis cache.</span></span> <span data-ttu-id="99855-115">Microsoft에서 관리하는 안전한 전용 Redis Cache에 액세스할 수 있게 합니다.</span><span class="sxs-lookup"><span data-stu-id="99855-115">It gives you access to a secure, dedicated Redis cache, managed by Microsoft.</span></span> <span data-ttu-id="99855-116">Azure Redis Cache를 사용하여 만들어진 캐시는 Microsoft Azure 내의 모든 응용 프로그램에서 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="99855-116">A cache created using Azure Redis Cache is accessible from any application within Microsoft Azure.</span></span> <span data-ttu-id="99855-117">Azure Redis Cache는 일반적으로 백 엔드 데이터 저장소에 크게 의존하는 시스템의 성능을 개선하기 위해 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="99855-117">Azure Redis Cache is typically used to improve the performance of systems that rely heavily on back-end data stores.</span></span>

<span data-ttu-id="99855-118">캐시된 데이터는 데이터베이스에 의해 디스크에서 로드되는 것과는 반대로 Redis Cache를 실행하는 Azure 서버에서 메모리 내에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="99855-118">Your cached data is located in-memory on an Azure server running the Redis cache as opposed to being loaded from disk by a database.</span></span> <span data-ttu-id="99855-119">캐시도 확장성이 높습니다.</span><span class="sxs-lookup"><span data-stu-id="99855-119">Your cache is also highly scalable.</span></span> <span data-ttu-id="99855-120">언제든지 크기 및 가격 책정 계층을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="99855-120">You can alter the size and pricing tier at any time.</span></span>

## <a name="what-type-of-data-can-be-stored-in-the-cache"></a><span data-ttu-id="99855-121">캐시에 어떤 유형의 데이터를 저장할 수 있습니까?</span><span class="sxs-lookup"><span data-stu-id="99855-121">What type of data can be stored in the cache?</span></span>

<span data-ttu-id="99855-122">Redis는 _안전한 이진_ 문자열을 지향하는 다양한 유형의 데이터를 모두 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="99855-122">Redis supports a variety of data types all oriented around _binary safe_ strings.</span></span> <span data-ttu-id="99855-123">즉, "i-love-rocky-road" 같은 문자열부터 이미지 파일의 콘텐츠까지 모든 이진 시퀀스를 값에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="99855-123">This means that you can use any binary sequence for a value, from a string like "i-love-rocky-road" to the contents of an image file.</span></span> <span data-ttu-id="99855-124">빈 문자열도 유효한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="99855-124">An empty string is also a valid value.</span></span>

- <span data-ttu-id="99855-125">안전한 이진 문자열(가장 일반적)</span><span class="sxs-lookup"><span data-stu-id="99855-125">Binary-safe strings (most common)</span></span>
- <span data-ttu-id="99855-126">문자열 목록</span><span class="sxs-lookup"><span data-stu-id="99855-126">Lists of strings</span></span>
- <span data-ttu-id="99855-127">순서가 지정되지 않은 문자열 집합</span><span class="sxs-lookup"><span data-stu-id="99855-127">Unordered sets of strings</span></span>
- <span data-ttu-id="99855-128">해시</span><span class="sxs-lookup"><span data-stu-id="99855-128">Hashes</span></span>
- <span data-ttu-id="99855-129">정렬된 문자열 집합</span><span class="sxs-lookup"><span data-stu-id="99855-129">Sorted sets of strings</span></span>
- <span data-ttu-id="99855-130">문자열 맵</span><span class="sxs-lookup"><span data-stu-id="99855-130">Maps of strings</span></span>

<span data-ttu-id="99855-131">각 데이터 값은 캐시에서 값을 조회하는 데 사용할 수 있는 _키_에 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="99855-131">Each data value is associated to a _key_ which can be used to lookup the value from the cache.</span></span> <span data-ttu-id="99855-132">Redis는 작은 값(100k 이하)에서 가장 잘 작동하므로 큰 데이터를 여러 개의 키로 분할하는 방안을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="99855-132">Redis works best with smaller values (100k or less), so consider chopping up bigger data into multiple keys.</span></span> <span data-ttu-id="99855-133">큰 값을 저장할 수는 있지만(최대 500MB), 네트워크 대기 시간이 증가하고 오래된 값을 만료하도록 캐시를 구성하지 않으면 캐싱 및 메모리 부족 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="99855-133">Storing larger values is possible (up to 500 MB), but increases network latency and can cause caching and out-of-memory issues if the cache isn't configured to expire old values.</span></span>

## <a name="what-is-a-redis-key"></a><span data-ttu-id="99855-134">Redis 키란?</span><span class="sxs-lookup"><span data-stu-id="99855-134">What is a Redis key?</span></span>
<span data-ttu-id="99855-135">Redis 키 역시 안전한 이진 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="99855-135">Redis keys are also binary safe strings.</span></span> <span data-ttu-id="99855-136">다음은 키를 선택하는 방법에 대한 지침입니다.</span><span class="sxs-lookup"><span data-stu-id="99855-136">Here are some guidelines for choosing keys:</span></span>

- <span data-ttu-id="99855-137">긴 키를 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="99855-137">Avoid long keys.</span></span> <span data-ttu-id="99855-138">바이트 단위로 비교해야 하기 때문에 더 많은 메모리를 차지하고 조회 시간이 오래 걸립니다.</span><span class="sxs-lookup"><span data-stu-id="99855-138">They take up more memory and require longer lookup times because they have to be compared byte-by-byte.</span></span> <span data-ttu-id="99855-139">이진 BLOB을 키로 사용하려는 경우 고유한 해시를 생성하여 키 대신 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="99855-139">If you want to use a binary blob as the key, generate a unique hash and use that as the key instead.</span></span> <span data-ttu-id="99855-140">키의 최대 크기는 512MB지만, 이 크기의 키를 _절대_ 사용하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="99855-140">The maximum size of a key is 512 MB, but you should _never_ use a key that size.</span></span>
- <span data-ttu-id="99855-141">데이터를 식별할 수 있는 키를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="99855-141">Use keys which can identify the data.</span></span> <span data-ttu-id="99855-142">예를 들어 "fb:8-2-2"보다 "sport:football;date:2008-02-02"가 더 좋은 키입니다.</span><span class="sxs-lookup"><span data-stu-id="99855-142">For example, "sport:football;date:2008-02-02" would be a better key than "fb:8-2-2".</span></span> <span data-ttu-id="99855-143">전자가 더 읽기 쉬우며 추가 크기는 무시해도 되는 수준입니다.</span><span class="sxs-lookup"><span data-stu-id="99855-143">The former is more readable and the extra size is negligible.</span></span> <span data-ttu-id="99855-144">크기와 가독성 사이의 적절한 균형점을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="99855-144">Find the balance between size and readability.</span></span>
- <span data-ttu-id="99855-145">규칙을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="99855-145">Use a convention.</span></span> <span data-ttu-id="99855-146">"sport:football"처럼 "object:id"가 좋은 키입니다.</span><span class="sxs-lookup"><span data-stu-id="99855-146">A good one is "object:id", as in "sport:football".</span></span> 

## <a name="how-is-data-stored-in-a-redis-cache"></a><span data-ttu-id="99855-147">데이터는 Redis 캐시에 어떻게 저장되나요?</span><span class="sxs-lookup"><span data-stu-id="99855-147">How is data stored in a Redis cache?</span></span>

<span data-ttu-id="99855-148">Redis의 데이터는 ‘**노드**’ 및 ‘**클러스터**’에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="99855-148">Data in Redis is stored in _**nodes**_ and _**clusters**_.</span></span>

<span data-ttu-id="99855-149">**노드**는 데이터가 저장되는 Redis의 공간입니다.</span><span class="sxs-lookup"><span data-stu-id="99855-149">**Nodes** are a space in Redis where your data is stored.</span></span>

<span data-ttu-id="99855-150">**클러스터**는 데이터 집합이 분할되는 세 개 이상 노드의 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="99855-150">**Clusters** are sets of three or more nodes your dataset is split across.</span></span> <span data-ttu-id="99855-151">클러스터의 경우 노드가 작동하지 않거나 클러스터의 나머지 부분과 통신할 수 없는 경우 작업이 계속되므로 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="99855-151">Clusters are useful because your operations will continue if a node fails or is unable to communicate to the rest of the cluster.</span></span>

## <a name="what-are-redis-caching-architectures"></a><span data-ttu-id="99855-152">Redis 캐싱 아키텍처란?</span><span class="sxs-lookup"><span data-stu-id="99855-152">What are Redis caching architectures?</span></span>

<span data-ttu-id="99855-153">Redis 캐싱 아키텍처는 캐시에 데이터를 배포하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="99855-153">Redis caching architecture is how we distribute our data in the cache.</span></span> <span data-ttu-id="99855-154">Redis는 세 가지 주요 방법으로 데이터를 배포합니다.</span><span class="sxs-lookup"><span data-stu-id="99855-154">Redis distributes data in three major ways:</span></span>

1. <span data-ttu-id="99855-155">**단일 노드**</span><span class="sxs-lookup"><span data-stu-id="99855-155">**Single node**</span></span>
1. <span data-ttu-id="99855-156">**다중 노드**</span><span class="sxs-lookup"><span data-stu-id="99855-156">**Multiple node**</span></span>
1. <span data-ttu-id="99855-157">**클러스터형**.</span><span class="sxs-lookup"><span data-stu-id="99855-157">**Clustered**</span></span>

<span data-ttu-id="99855-158">Redis 캐싱 아키텍처는 Azure에서 계층별로 분할됩니다.</span><span class="sxs-lookup"><span data-stu-id="99855-158">Redis caching architectures are split across Azure by tiers:</span></span>

### <a name="basic-cache"></a><span data-ttu-id="99855-159">기본 캐시</span><span class="sxs-lookup"><span data-stu-id="99855-159">Basic cache</span></span>

<span data-ttu-id="99855-160">기본 캐시는 ‘**단일 노드**’ Redis Cache를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="99855-160">A basic cache provides you with a _**single node**_ Redis cache.</span></span> <span data-ttu-id="99855-161">전체 데이터 집합이 단일 노드에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="99855-161">The complete dataset will be stored in a single node.</span></span> <span data-ttu-id="99855-162">이 계층은 개발, 테스트 및 중요하지 않은 워크로드에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="99855-162">This tier is ideal for development, testing, and non-critical workloads.</span></span>

### <a name="standard-cache"></a><span data-ttu-id="99855-163">표준 캐시</span><span class="sxs-lookup"><span data-stu-id="99855-163">Standard cache</span></span>

<span data-ttu-id="99855-164">표준 캐시는 ‘**다중 노드**’ 아키텍처를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="99855-164">The standard cache creates _**multiple node**_ architectures.</span></span> <span data-ttu-id="99855-165">Redis는 2개 노드의 기본/보조 구성으로 캐시를 복제합니다.</span><span class="sxs-lookup"><span data-stu-id="99855-165">Redis replicates a cache in a two-node primary/secondary configuration.</span></span> <span data-ttu-id="99855-166">Azure는 두 노드 간의 복제를 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="99855-166">Azure manages the replication between the two nodes.</span></span> <span data-ttu-id="99855-167">이는 마스터/슬레이브 복제를 사용하는 프로덕션 준비가 완료된 캐시입니다.</span><span class="sxs-lookup"><span data-stu-id="99855-167">This is a production-ready cache with master/slave replication.</span></span>

### <a name="premium-tier"></a><span data-ttu-id="99855-168">프리미엄 계층</span><span class="sxs-lookup"><span data-stu-id="99855-168">Premium tier</span></span>

<span data-ttu-id="99855-169">프리미엄 계층에는 표준 계층의 기능이 포함되지만 데이터를 지속하고, 스냅숏을 찍고, 데이터를 백업하는 기능이 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="99855-169">The premium tier includes the features of the standard tier but adds the ability to persist data, take snapshots, and back up data.</span></span> <span data-ttu-id="99855-170">이 계층을 사용하면 여러 Redis 노드 간에 데이터를 분할하여 사용 가능한 메모리를 늘리는 Redis 클러스터를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="99855-170">With this tier, you can create a Redis cluster that shards data across multiple Redis nodes to increase available memory.</span></span> <span data-ttu-id="99855-171">또한 프리미엄 계층은 연결, 서브넷, IP 주소 지정 및 네트워크 격리를 완벽하게 제어할 수 있도록 Azure Virtual Network를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="99855-171">The premium tier also supports an Azure Virtual Network to give you complete control over your connections, subnets, IP addressing, and network isolation.</span></span> <span data-ttu-id="99855-172">이 계층에는 지역 복제가 포함되므로 데이터가 해당 계층을 사용하는 앱에 가까이 있는지 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="99855-172">This tier also includes geo-replication, so you can ensure your data is close to the app that's consuming it.</span></span>

## <a name="summary"></a><span data-ttu-id="99855-173">요약</span><span class="sxs-lookup"><span data-stu-id="99855-173">Summary</span></span>

<span data-ttu-id="99855-174">데이터베이스는 많은 양의 데이터를 저장하는 데 유용하지만 데이터를 조회할 때 고유 대기 시간이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="99855-174">A database is great for storing large amounts of data, but there is an inherent latency when looking up data.</span></span> <span data-ttu-id="99855-175">쿼리를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="99855-175">You send a query.</span></span> <span data-ttu-id="99855-176">서버는 쿼리를 해석하고 데이터를 검색한 후 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="99855-176">The server interprets the query, looks up the data, and returns it.</span></span> <span data-ttu-id="99855-177">서버에는 요청 처리를 위한 용량 제한도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="99855-177">Servers also have capacity limits for handling requests.</span></span> <span data-ttu-id="99855-178">너무 많은 요청이 생성되면 데이터 검색 속도가 느려질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="99855-178">If too many requests are made, data retrieval will likely slow down.</span></span> <span data-ttu-id="99855-179">캐싱은 데이터베이스를 쿼리하는 것보다 더 빠르게 반환될 수 있는 메모리에 자주 요청되는 데이터를 저장하므로, 대기 시간이 짧아지고 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="99855-179">Caching will store frequently requested data in memory that can be returned faster than querying a database, which should lower latency and increase performance.</span></span> <span data-ttu-id="99855-180">Azure Redis Cache를 통해 Azure에서 호스트하고 Microsoft에서 관리하는 안전하고 확장성 있는 전용 Redis Cache에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="99855-180">Azure Redis Cache gives you access to a secure, dedicated, and scalable Redis cache, hosted in Azure, and managed by Microsoft.</span></span>
