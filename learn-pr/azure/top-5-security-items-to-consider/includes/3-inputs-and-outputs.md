<span data-ttu-id="617ed-101">오늘날 가장 일반적인 응용 프로그램 보안 취약점은 외부 소스에서 받은 입력, 특히 _사용자 입력_을 올바르게 처리하지 못하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-101">The most prevalent security weakness of applications today is to not correctly process input received from external sources, particularly _user input_.</span></span> <span data-ttu-id="617ed-102">항상 입력을 면밀하게 살펴보고 유효성을 검사한 후 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-102">You should always take a close look at any input to make sure it has been validated before it is used.</span></span> <span data-ttu-id="617ed-103">그렇지 않으면 데이터가 손실 또는 노출되거나, 권한이 상승하거나, 심지어 다른 사용자의 컴퓨터에서 악성 코드가 실행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-103">Failing to do this can result in data loss or exposure, escalation of privilege, or even execution of malicious code on other users' computers.</span></span>

<span data-ttu-id="617ed-104">슬프게도 이 문제는 간단하게 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-104">The tragic thing is that this is an easy problem to solve.</span></span> <span data-ttu-id="617ed-105">여기서는 데이터를 처리하는 방법, 다시 말해서 데이터를 언제 수신할 것인지, 데이터를 언제 화면에 표시할 것인지, 나중에 사용할 수 있도록 데이터를 언제 저장할 것인지에 대해 알아보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-105">Here we will cover how to treat data; when it’s received, when it’s displayed on the screen, and when it's stored for later use.</span></span>

## <a name="why-do-we-need-to-validate-our-input"></a><span data-ttu-id="617ed-106">입력의 유효성을 검사해야 하는 이유는 무엇일까요?</span><span class="sxs-lookup"><span data-stu-id="617ed-106">Why do we need to validate our input?</span></span>

<span data-ttu-id="617ed-107">사용자가 웹 사이트에서 계정을 만들 수 있도록 인터페이스를 빌드하고 있다고 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-107">Imagine that you are building an interface to allow a user to create an account on your website.</span></span> <span data-ttu-id="617ed-108">프로필 데이터에는 사이트를 방문하는 모든 사람에게 표시할 이름, 이메일 및 애칭이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-108">Our profile data includes a name, email, and a nickname that we will display to everyone who visits the site.</span></span> <span data-ttu-id="617ed-109">신규 사용자가 프로필을 만들고 몇 가지 SQL 명령이 포함된 애칭을 입력하면 어떻게 될까요?</span><span class="sxs-lookup"><span data-stu-id="617ed-109">What if a new user creates a profile and enters a nickname that includes some SQL commands?</span></span> <span data-ttu-id="617ed-110">예를 들어 나쁜 마음을 품은 사용자가 다음과 같이 입력하면 어떻게 될까요?</span><span class="sxs-lookup"><span data-stu-id="617ed-110">For example - what if our bad user enters something like:</span></span>

```sql
Eve'); DROP TABLE Users;--
```

<span data-ttu-id="617ed-111">아무 생각 없이 이 값을 데이터베이스에 삽입하면 절대 실행하면 안 되는 명령을 실행하도록 SQL 문이 변경될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-111">If we just blindly insert this value into a database, it could potentially alter the SQL statement to execute commands we absolutely don't want to run!</span></span> <span data-ttu-id="617ed-112">이것을 “SQL 삽입” 공격이라고 하며 입력을 제대로 처리하지 않을 때 발생할 수 있는 _여러_ 유형의 공격 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-112">This is referred to as a "SQL Injection" attack and is one of the _many_ types of exploits that can potentially be done when you don't properly handle inputs.</span></span> <span data-ttu-id="617ed-113">이 문제를 해결하려면 어떻게 해야 할까요?</span><span class="sxs-lookup"><span data-stu-id="617ed-113">So, what can we do to fix this?</span></span> <span data-ttu-id="617ed-114">이 단원에서는 입력의 유효성을 검사해야 하는 시기, 출력을 인코딩하는 방법, 매개 변수가 있는 큐를 만드는 방법(위의 공격을 해결하는 방법)을 알아보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-114">This unit will teach you when to validate input, how to encode output, and how to create parameterized queries (which solves the above exploit).</span></span> <span data-ttu-id="617ed-115">이 세 가지는 응용 프로그램에 입력되는 악의적인 입력을 방어하는 주요 방어 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-115">These are the three main defense techniques against malicious input being entered into your applications.</span></span>

## <a name="when-do-i-need-to-validate-input"></a><span data-ttu-id="617ed-116">언제 입력의 유효성을 검사해야 할까요?</span><span class="sxs-lookup"><span data-stu-id="617ed-116">When do I need to validate input?</span></span>

<span data-ttu-id="617ed-117">_항상_ 검사해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-117">The answer is _always_.</span></span> <span data-ttu-id="617ed-118">응용 프로그램에 대한 **모든** 입력의 유효성을 검사해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-118">You must validate **every** input for your application.</span></span> <span data-ttu-id="617ed-119">여기에는 URL의 매개 변수, 사용자의 입력, 데이터베이스의 데이터, API의 데이터, 전달되는 항목 중 사용자의 조작 가능성이 있는 모든 항목이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-119">This includes parameters in the URL, input from the user, data from the database, data from an API and anything that is passed in the clear that a user could potentially manipulate.</span></span> <span data-ttu-id="617ed-120">나쁜 입력을 구체적으로 찾아야 하는 블랙 리스트를 사용하지 말고, 항상 “알려진 좋은” 입력만 허용하는 허용 목록 방식을 사용하세요. 목록 전체를 위험한 입력이라고 생각하기는 불가능하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-120">Always use a whitelist approach, which means you only accept "known good" input, instead of a blacklist (where you specifically look for bad input) because it's impossible to think of a complete list of potentially dangerous input.</span></span>  <span data-ttu-id="617ed-121">방어벽을 회피할 수 없도록 이 작업을 클라이언트 쪽이 아닌 서버에서 수행하세요(또는 서버에서도 하고 클라이언트 쪽에서도 하세요).</span><span class="sxs-lookup"><span data-stu-id="617ed-121">Do this work on the server, not the client-side (or in addition to the client-side), to ensure that your defenses cannot be circumvented.</span></span> <span data-ttu-id="617ed-122">**모든** 데이터를 신뢰할 수 없다고 생각하고 대부분의 일반적인 웹앱 취약점으로부터 자신을 보호해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-122">Treat **ALL** data as untrusted and you will protect yourself from most of the common web app vulnerabilities.</span></span>

<span data-ttu-id="617ed-123">ASP.NET을 사용하는 경우 프레임워크에서 클라이언트와 서버 쪽 모두에 [입력의 유효성을 검사하는 훌륭한 지원](https://docs.microsoft.com/aspnet/web-pages/overview/ui-layouts-and-themes/validating-user-input-in-aspnet-web-pages-sites)을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-123">If you are using ASP.NET, the framework provides [great support for validating input](https://docs.microsoft.com/aspnet/web-pages/overview/ui-layouts-and-themes/validating-user-input-in-aspnet-web-pages-sites) on both the client and server side.</span></span>

<span data-ttu-id="617ed-124">다른 웹 프레임워크를 사용하는 경우 [OWASP 입력 유효성 검사 참고 자료](https://www.owasp.org/index.php/Input_Validation_Cheat_Sheet)에 입력의 유효성을 검사하는 유용한 기술이 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-124">If you are using another web framework, there are some great techniques for doing input validation available on the [OWASP Input Validation Cheatsheet](https://www.owasp.org/index.php/Input_Validation_Cheat_Sheet).</span></span>


## <a name="always-use-parameterized-queries"></a><span data-ttu-id="617ed-125">항상 매개 변수가 있는 쿼리 사용</span><span class="sxs-lookup"><span data-stu-id="617ed-125">Always use parameterized queries</span></span>

<span data-ttu-id="617ed-126">SQL 데이터베이스는 프로필 정보와 같은 데이터를 저장하는 데 주로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-126">SQL databases are commonly used to store data, for example profile information.</span></span>  <span data-ttu-id="617ed-127">절대로 “즉석에서” 코드에 인라인 SQL 또는 다른 데이터베이스 쿼리를 만들어서 데이터베이스에 직접 전송하지 마세요. 위에서 살펴보았지만, 이것은 재앙을 부르는 행위입니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-127">Never create inline SQL or other database queries "on the fly" in your code and send it directly to the database, this is a recipe for disaster, as we saw above.</span></span>

<span data-ttu-id="617ed-128">예를 들어 **이렇게 하지 마세요**(인라인 SQL이라고도 함).</span><span class="sxs-lookup"><span data-stu-id="617ed-128">For example, **do not do this** (known as inline SQL):</span></span>

```csharp
string userName = ... // receive input from the user BEWARE!
...
string query = "SELECT *  FROM  [dbo].[users] WHERE userName = '" + userName + "'";
```

<span data-ttu-id="617ed-129">여기서는 텍스트 문자열을 서로 연결하여 쿼리를 만들고, 사용자의 입력을 가져와서 사용자를 조회하는 동적 SQL 쿼리를 생성하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-129">Here we concatenate text strings together to create the query, taking the input from the user and generating a dynamic SQL query to lookup the user.</span></span> <span data-ttu-id="617ed-130">기억해야 할 부분은 악의적인 사용자가 이 작업을 알아차리거나 취약성을 찾기 위해 여러 입력 스타일을 _시도_하는 경우 심각한 문제가 발생할 수 있다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-130">Again, if a malicious user realized we were doing this, or just _tried_ different input styles to see if there was a vulnerability, we could end up with a major disaster.</span></span> <span data-ttu-id="617ed-131">대신 다음과 같이 매개 변수가 있는 SQL 문이나 저장 프로시저를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-131">Instead, use parameterized SQL statements or stored procedures such as this:</span></span>

```sql
-- Lookup a user
CREATE PROCEDURE sp_findUser
(
@UserName varchar(50)
)

SELECT *  FROM  [dbo].[users] WHERE userName = @UserName
```

<span data-ttu-id="617ed-132">이 방법을 사용하면 코드에서 안전하게 프로시저를 호출하여 `userName` 문자열을 전달할 수 있으며 SQL 문의 일부로 처리될까 봐 걱정하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-132">With this method you can invoke the procedure from your code safely, passing it the `userName` string without worrying about it being treated as part of the SQL statement.</span></span>

## <a name="always-encode-your-output"></a><span data-ttu-id="617ed-133">항상 출력을 인코딩</span><span class="sxs-lookup"><span data-stu-id="617ed-133">Always encode your output</span></span>

<span data-ttu-id="617ed-134">시각적으로 또는 문서로 제공하는 모든 출력을 항상 인코딩하고 이스케이프해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-134">Any output you present either visually or within a document should always be encoded and escaped.</span></span> <span data-ttu-id="617ed-135">그러면 삭제 패스에서 무언가가 누락되었거나 악의적으로 사용 가능한 무언가를 코드에서 실수로 생성한 경우에 데이터를 보호할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-135">This can protect you in case something was missed in the sanitization pass, or the code accidentally generates something that can be used maliciously.</span></span> <span data-ttu-id="617ed-136">이렇게 하면 모든 것이 _출력_으로 표시되며, 의도치 않게 실행해야 하는 항목으로 해석되는 일이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-136">This will make sure that everything is displayed as _output_ and not inadvertently interpreted as something that should be executed.</span></span> <span data-ttu-id="617ed-137">이것이 “XSS”(교차 사이트 스크립팅)라고 하는 또 다른 매우 일반적인 공격 기법입니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-137">This is another very common attack technique referred to as "Cross-Site Scripting" (XSS).</span></span>

<span data-ttu-id="617ed-138">이것은 매우 일반적인 요구 사항이므로 ASP.NET이 작업을 수행하는 또 다른 영역입니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-138">Since this is such as common requirement, this is another area where ASP.NET will do the work for you.</span></span> <span data-ttu-id="617ed-139">기본적으로 모든 출력이 이미 인코딩되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-139">By default, all output is already encoded.</span></span> <span data-ttu-id="617ed-140">다른 웹 프레임워크를 사용하는 경우 [OWASP XSS 방지 참고 자료](https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet)를 사용하여 웹 사이트의 출력 인코딩에 대한 옵션을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-140">If you are using another web framework, you can verify your options for output encoding on websites with the [OWASP XSS Prevention Cheatsheet](https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet).</span></span>

## <a name="summary"></a><span data-ttu-id="617ed-141">요약</span><span class="sxs-lookup"><span data-stu-id="617ed-141">Summary</span></span>

<span data-ttu-id="617ed-142">입력 삭제 및 유효성 검사는 입력의 유효성을 보장하고 안전하게 사용 및 저장하기 위한 필수 요구 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-142">Santizing and validating your input is a necessary requirement to ensure your input is valid and safe to use and store.</span></span> <span data-ttu-id="617ed-143">대부분의 최신 웹 프레임워크는 이 작업 중 일부를 자동화할 수 있는 기능을 기본 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-143">Most modern web frameworks offer built-in features which can automate some of this work.</span></span> <span data-ttu-id="617ed-144">원하는 프레임워크의 설명서를 확인하고 제공된 기능을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-144">You can check your preferred framework's documentation and see what features it offers.</span></span> <span data-ttu-id="617ed-145">웹 응용 프로그램에서는 이러한 문제가 가장 흔히 발생하지만, 다른 유형의 응용 프로그램도 그 정도로 취약할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-145">While web applications are the most common place where this happens, keep in mind that other types of applications can be just as vulnerable.</span></span> <span data-ttu-id="617ed-146">새 응용 프로그램이 데스크톱 앱이기 때문에 안전하다고는 생각하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="617ed-146">Don't think you're safe just because your new application is a desktop app.</span></span> <span data-ttu-id="617ed-147">다른 사용자가 앱을 사용하여 데이터를 손상하거나 회사의 평판을 낮추는 일이 없도록 계속해서 사용자 입력을 적절하게 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="617ed-147">You will still need to properly handle user input to ensure someone doesn't use your app to corrupt your data, or damage your company's reputation.</span></span>