응용 프로그램의 가장 널리 알려진 보안 취약성 잘못 특히 외부 원본에서 받은 입력을 처리 하는 데 임 _사용자 입력_합니다. 항상 사용 되기 전에 검증 된 되도록 모든 입력의 세부적인 모습을 수행 해야 합니다. 이렇게 데이터 손실 또는 노출, 권한 상승 또는 다른 사용자의 컴퓨터에서 악성 코드에도 실행 될 수 있습니다.

비참 것이 간단한 문제를 해결 하는 것입니다. 여기에서는 다룰 데이터를 처리 하는 방법 이 받을 때, 화면에 표시 되 고 나중에 사용할 저장 되는 경우.

## <a name="why-do-we-need-to-validate-our-input"></a>입력의 유효성을 검사 해야 하는 이유는 우리가?

사용자가 웹 사이트에 계정을 만들 수 있도록 인터페이스를 빌드하고 있다고 가정해 보겠습니다. 프로필 데이터는 이름, 메일 및 사이트 방문자에 게 모든 사용자에 게 표시 되는 애칭을 포함 합니다. 그렇다면 새 사용자 프로필을 만들고 몇 가지 SQL 명령을 포함 하는 애칭을 입력? 예를 들어 경우 잘못 된 사용자가 같은:

```output
Eve'); DROP TABLE Users;--
```

무조건만 데이터베이스에이 값을 삽입 했습니다 하는 경우 반드시 실행 하려고 하지 않습니다 하는 명령을 실행 하는 SQL 문을 잠재적으로 변경할 수 것! 이 "SQL 삽입" 공격 이라고 이며 중 하나는 _많은_ 입력 제대로 처리 하지 않습니다 하는 경우 잠재적으로 수행할 수 있는 공격 유형입니다. 따라서 어떻게 하면 좋겠습니까 문제를 해결 하려면? 이 단위는 설명 하는 매개 변수가 입력, 출력을 인코딩하는 방법 및 만드는 방법의 유효성을 검사 하는 경우 쿼리 (해결 하는 위의 공격) 합니다. 이들은 응용 프로그램에 입력 되는 악의적인 입력에 대 한 세 가지 주요 방어 기술입니다.

## <a name="when-do-i-need-to-validate-input"></a>입력의 유효성을 검사 해야 하는 경우는 합니까?

대답이 _항상_합니다. 유효성을 검사 해야 합니다 **마다** 응용 프로그램에 대 한 입력 합니다. 이 사용자, 데이터베이스에서 데이터, 사용자 조작 될 수 있는 일반 텍스트로 전달 되는 API 및 작업에서 데이터의 입력 URL에 매개 변수를 포함 합니다. 항상 잠재적으로 위험한 입력의 전체 목록은 생각 하는 것이 불가능 하기 때문에 (여기서 구체적으로 보면 잘못 된 입력에 대 한) 블랙 리스트 대신 "알려진 양호한" 입력을 받아들일 화이트 리스트 접근 방식을 사용 합니다.  서버에서 클라이언트 쪽 없습니다 (또는 클라이언트 쪽 외에도)이이 작업을 수행, 약해집니다 되도록 방해할 수 없습니다. 처리할 **모든** 를 신뢰할 수 없는 데이터를 보호 직접 대부분의 일반적인 웹 앱 취약점입니다.

프레임 워크를 제공 하는 ASP.NET을 사용 하는 경우 [입력 유효성 검사에 대 한 훌륭한 지원을](https://docs.microsoft.com/aspnet/web-pages/overview/ui-layouts-and-themes/validating-user-input-in-aspnet-web-pages-sites) 클라이언트와 서버 쪽에서 합니다.

다른 웹 프레임 워크를 사용 하는 경우 몇 가지 유용한 기술이 입력된 유효성 검사에 사용할 수 있는 작업을 수행 하는 [OWASP 입력 유효성 검사 치트 시트](https://www.owasp.org/index.php/Input_Validation_Cheat_Sheet)합니다.


## <a name="always-use-parameterized-queries"></a>항상 매개 변수가 있는 쿼리를 사용 하 여

SQL database는 데이터, 예를 들어 프로필 정보를 저장할 자주 사용 됩니다.  인라인을 작성 하지 말아야 위에서 말한 것 처럼이 재해가 발생 하는 작성법, SQL 또는 기타 코드에서 "즉시"에 대 한 쿼리를 데이터베이스 및 데이터베이스에 직접 전송 합니다.

예를 들어 **이렇게 하지 않으면** (인라인 SQL 라고도 함):

```csharp
string userName = ... // receive input from the user BEWARE!
...
string query = "SELECT *  FROM  [dbo].[users] WHERE userName = '" + userName + "'";
```

여기서 사용자 로부터 입력을 수행 하 고 사용자를 조회 하는 동적 SQL 쿼리를 생성 쿼리를 만드는 데 텍스트 문자열을 연결 했습니다. 마찬가지로 악의적인 사용자가 실현에서는이 수행 되었거나 방금 _시도_ 취약점에 발생 한 경우 수를 얻게 재난이 보려는 다양 한 입력된 스타일입니다. 매개 변수가 있는 SQL 문 또는 이와 같은 저장된 프로시저를 대신 사용 합니다.

```sql
-- Lookup a user
CREATE PROCEDURE sp_findUser
(
@UserName varchar(50)
)

SELECT *  FROM  [dbo].[users] WHERE userName = @UserName
```

이 메서드를 사용 하 여 호출할 수 있습니다 프로시저 코드에서 안전 하 게 전달 된 `userName` SQL 문의 일부로 처리 되 고이 대 한 걱정 없이 문자열입니다.

## <a name="always-encode-your-output"></a>항상 출력 인코딩

시각적으로 또는 문서 내에서 제공 하는 모든 출력 인코딩 고 항상 이스케이프 해야 합니다. 이 경우 삭제가 패스에서 누락 된 항목 또는 악의적으로 사용할 수 있는 무언가 코드를 실수로 생성 보호할 수 있습니다. 이렇게 하면 모든 항목으로 표시 됩니다 _출력_ 실행 되어야 하는 것으로 해석 하지 않도록 합니다. 이것이 "교차 사이트 스크립팅" (XSS) 라고 하는 또 다른 매우 일반적인 공격 기법입니다.

이 일반적인 요구 사항 같은 이므로 여기서 ASP.NET는 작업을 수행 하면 다른 영역입니다. 기본적으로 [모든 출력이 이미 인코딩된](https://docs.microsoft.com/aspnet/core/security/cross-site-scripting?view=aspnetcore-2.1)합니다. 다른 웹 프레임 워크를 사용 하는 경우에 출력 인코딩을 사용 하 여 웹 사이트에 대 한 옵션을 확인할 수 있습니다 합니다 [OWASP XSS 방지 참고 자료](https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet)합니다.

## <a name="summary"></a>요약

Santizing 및 입력 유효성 검사는 입력이 유효 하 고 안전 하 게 사용 하 고 저장 하도록 필요한 요구 사항입니다. 대부분의 최신 웹 프레임 워크는 이러한 작업 중 일부를 자동화할 수 있는 기본 제공 기능을 제공 합니다. 기본 프레임 워크의 설명서를 확인 하 고 제품 기능을 볼 수 있습니다. 웹 응용 프로그램은이 문제가 가장 일반적인 위치에서 다른 유형의 응용 프로그램 바로 취약 하다 수 있음을 염두에서에 둡니다. 새 응용 프로그램은 데스크톱 앱 단지 안전할 수를 생각 하지 마십시오. 다른 사용자가 앱을 사용 하 여 데이터를 손상 하거나 회사의 평판 손상 하지 되도록 사용자 입력을 제대로 처리를 계속 해야 합니다.