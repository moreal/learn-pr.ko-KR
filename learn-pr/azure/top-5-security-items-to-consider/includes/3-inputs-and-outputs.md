오늘날 가장 일반적인 응용 프로그램 보안 취약점은 외부 소스에서 받은 입력, 특히 _사용자 입력_을 올바르게 처리하지 못하는 것입니다. 항상 입력을 면밀하게 살펴보고 유효성을 검사한 후 사용해야 합니다. 그렇지 않으면 데이터가 손실 또는 노출되거나, 권한이 상승되거나, 심지어 다른 사용자의 컴퓨터에서 악성 코드가 실행될 수 있습니다.

슬프게도 이 문제는 간단하게 해결할 수 있습니다. 여기서는 데이터를 처리하는 방법, 다시 말해서 데이터를 언제 수신할 것인지, 데이터를 언제 화면에 표시할 것인지, 나중에 사용할 수 있도록 데이터를 언제 저장할 것인지에 대해 알아보겠습니다.

## <a name="why-do-we-need-to-validate-our-input"></a>입력의 유효성을 검사해야 하는 이유는 무엇일까요?

사용자가 웹 사이트에서 계정을 만들 수 있도록 인터페이스를 빌드하고 있다고 가정해 보겠습니다. 프로필 데이터에는 사이트를 방문하는 모든 사람에게 표시할 이름, 이메일 및 애칭이 포함됩니다. 신규 사용자가 프로필을 만들고 몇 가지 SQL 명령이 포함된 애칭을 입력하면 어떻게 될까요? 예를 들어 나쁜 마음을 품은 사용자가 다음과 같이 입력하면 어떻게 될까요?

```output
Eve'); DROP TABLE Users;--
```

아무 생각 없이 이 값을 데이터베이스에 삽입하면 절대 실행하면 안 되는 명령을 실행하도록 SQL 문이 변경될 수 있습니다. 이것을 "SQL 삽입" 공격이라고 하며 입력을 제대로 처리하지 않을 때 발생할 수 있는 _여러_ 유형의 공격 중 하나입니다. 이 문제를 해결하려면 어떻게 해야 할까요? 이 모듈에서는 입력을 삭제해야 하는 시기, 출력을 인코딩하는 방법, 매개 변수가 있는 큐를 만드는 방법(위의 공격을 해결하는 방법)을 알아보겠습니다. 이 세 가지는 응용 프로그램에 입력되는 악의적인 입력을 방어하는 주요 방어 기술입니다.

## <a name="when-do-i-need-to-validate-input"></a>언제 입력의 유효성을 검사해야 할까요?

_항상_ 검사해야 합니다. 응용 프로그램에 대한 **모든** 입력의 유효성을 검사해야 합니다. 여기에는 URL의 매개 변수, 사용자의 입력, 데이터베이스의 데이터, API의 데이터, 전달되는 항목 중 사용자의 조작 가능성이 있는 모든 항목이 포함됩니다. 나쁜 입력을 구체적으로 찾아야 하는 블랙 리스트를 사용하지 말고, 항상 "알려진 좋은" 입력만 허용하는 허용 목록 방식을 사용하세요. 목록 전체를 위험한 입력이라고 생각하기는 불가능하기 때문입니다.  방어벽을 회피할 수 없도록 이 작업을 클라이언트 쪽이 아닌 서버에서 수행하세요(또는 서버에서도 하고 클라이언트 쪽에서도 하세요). **모든** 데이터를 신뢰할 수 없다고 생각하고 대부분의 일반적인 웹앱 취약점으로부터 자신을 보호해야 합니다.

ASP.NET을 사용하는 경우 프레임워크에서 클라이언트와 서버 쪽 모두에 [입력의 유효성을 검사하는 훌륭한 지원](https://docs.microsoft.com/aspnet/web-pages/overview/ui-layouts-and-themes/validating-user-input-in-aspnet-web-pages-sites)을 제공합니다.

다른 웹 프레임워크를 사용하는 경우 [OWASP 입력 유효성 검사 참고 자료](https://www.owasp.org/index.php/Input_Validation_Cheat_Sheet)에 입력의 유효성을 검사하는 유용한 기술이 제공됩니다.


## <a name="always-use-parameterized-queries"></a>항상 매개 변수가 있는 쿼리 사용

SQL 데이터베이스는 일반적으로 데이터를 저장하는 데 사용됩니다. 예를 들어 프로필 정보를 SQL Server에 저장할 수 있습니다.  절대로 "즉석에서" 코드에 인라인 SQL 또는 다른 데이터베이스 쿼리를 만들어서 데이터베이스에 직접 전송하지 마세요. 위에서 살펴보았지만, 이것은 재앙을 부르는 행위입니다.

예를 들어 **이렇게 하지 마세요**(인라인 SQL이라고도 함).

```csharp
string userName = ... // receive input from the user BEWARE!
...
string query = "SELECT *  FROM  [dbo].[users] WHERE userName = '" + userName + "'";
```

여기서는 텍스트 문자열을 서로 연결하여 쿼리를 만들고, 사용자의 입력을 가져와서 사용자를 조회하는 동적 SQL 쿼리를 생성하겠습니다. 다시 강조하지만, 악의적인 사용자가 우리가 이렇게 하고 있다는 사실을 알아차리거나 취약점이 있는지 알아보려고 여러 입력 스타일을 _시도_하는 경우 엄청난 재앙이 발생할 수 있습니다. 이렇게 하지 말고, 매개 변수가 있는 SQL 문을 사용하거나, 더 좋은 방법으로 저장 프로시저를 사용하세요.

```sql
-- Lookup a user
CREATE PROCEDURE sp_findUser
(
@UserName varchar(50)
)

SELECT *  FROM  [dbo].[users] WHERE userName = @UserName
```

그러면 코드에서 안전하게 프로시저를 호출하여 `userName` 문자열을 전달할 수 있으며 SQL 문의 일부로 처리될 까봐 걱정하지 않아도 됩니다.

## <a name="always-encode-your-output"></a>항상 출력을 인코딩

시각적으로 또는 파일로 제공하는 모든 출력을 항상 인코딩하고 이스케이프해야 합니다. 그러면 삭제 패스에서 무언가가 누락되었거나 악의적으로 사용 가능한 무언가를 코드에서 실수로 생성한 경우에 데이터를 보호할 수 있습니다. 이렇게 하면 모든 것이 _출력_으로 표시되며, 의도치 않게 실행해야 하는 항목으로 해석되는 일이 없습니다. 이것이 "XSS(교차 사이트 스크립팅)"라고 하는 또 다른 매우 일반적인 공격 기법입니다.

이것은 매우 일반적인 요구 사항이므로 ASP.NET이 알아서 작업을 수행하는 또 다른 영역입니다. 기본적으로 [모든 출력이 이미 인코딩되어 있습니다](https://docs.microsoft.com/en-us/aspnet/core/security/cross-site-scripting?view=aspnetcore-2.1). 다른 웹 프레임워크를 사용하는 경우 [OWASP XSS 방지 참고 자료](https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet)를 사용하여 웹 사이트의 출력 인코딩에 대한 옵션을 확인할 수 있습니다.

## <a name="summary"></a>요약

입력 삭제 및 유효성 검사는 입력의 유효성을 보장하고 안전하게 사용 및 저장하기 위한 필수 요구 사항입니다. 대부분의 최신 웹 프레임워크는 이 작업의 일부를 자동화할 수 있는 기능을 기본적으로 제공합니다. 선호하는 프레임워크의 설명서를 읽고 어떤 기능을 제공하는지 확인하세요. 또한 이 문제가 주로 발생하는 위치는 웹 응용 프로그램이지만, 다른 종류의 응용 프로그램에서도 비슷한 문제가 발생할 수 있으므로 멋진 데스크톱 앱을 작성하면 안전할 것이라는 생각을 버려야 합니다. 다른 사용자가 앱을 사용하여 데이터를 손상하거나 회사의 평판을 손상하는 일이 없도록 계속해서 사용자 입력을 적절하게 처리해야 합니다.


## <a name="knowledge-check"></a>지식 검사

다음 중 삭제해야 하는 데이터 원본은 무엇입니까?
* 타사 API의 데이터
* URL 매개 변수의 데이터
* 입력 필드를 통해 사용자로부터 수집한 데이터
* 위의 데이터 모두(정답)

다음 중 출력 인코딩해야 하는 데이터는 무엇입니까?
* 데이터베이스에 저장된 데이터
* 화면에 출력할 데이터(정답)
* 타사 API로 전송되는 데이터
* URL 매개 변수의 데이터

매개 변수가 있는 쿼리(SQL의 저장 프로시저)는 항상 데이터베이스와 좀 더 안전하게 통신하는 방법이며, 그 이유는 다음과 같습니다.
* 인라인 데이터베이스 명령보다 잘 조직화되어 있기 때문에 사용자가 혼동할 가능성이 적습니다.
* 저장 프로시저의 스크립트에 대한 명확한 개요가 있으므로 보다 나은 가시성을 보장합니다.
* 해커가 SQL로 프로그래밍하는 방법을 이해할 수 없습니다.
* 쿼리를 실행하기 전에 매개 변수가 있는 쿼리가 변수를 대체하므로 변수 대신 코드를 제출하는 가능성을 방지합니다. (정답)
