<span data-ttu-id="41f36-101">데이터를 저장해야 하는 앱을 디자인할 때는 앱이 저장소 계정, 컨테이너 및 Blob에서 데이터를 구성하는 방법을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-101">When designing an app that needs to store data, it's important to think about how the app is going to organize data across storage accounts, containers, and blobs.</span></span>

## <a name="storage-accounts"></a><span data-ttu-id="41f36-102">저장소 계정</span><span class="sxs-lookup"><span data-stu-id="41f36-102">Storage accounts</span></span>

<span data-ttu-id="41f36-103">단일 저장소 계정은 원하는 대로 Blob을 구성할 만큼 유연성이 있지만, 필요에 따라 추가 저장소 계정을 사용하여 논리적으로 비용을 구별하고 데이터에 대한 액세스를 제어해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-103">A single storage account is flexible enough to organize your blobs however you like, but you should use additional storage accounts as necessary to logically separate costs and control access to data.</span></span>

## <a name="containers-and-blobs"></a><span data-ttu-id="41f36-104">컨테이너 및 Blob</span><span class="sxs-lookup"><span data-stu-id="41f36-104">Containers and blobs</span></span>

<span data-ttu-id="41f36-105">응용 프로그램 및 응용 프로그램이 저장하는 데이터의 특성에 따라 컨테이너 및 Blob의 이름을 지정하고 이를 구성하는 전략을 결정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-105">The nature of your application and the data that it stores should drive your strategy for naming and organizing containers and blobs.</span></span>

<span data-ttu-id="41f36-106">데이터베이스를 포함하는 저장소 체계의 일부로 Blob을 사용하는 앱은 데이터에 대한 정보를 표시하는 데 주로 구성, 이름 지정 또는 메타데이터를 사용할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-106">Apps using blobs as part of a storage scheme that includes a database often don't need to rely heavily on organization, naming, or metadata to indicate anything about their data.</span></span> <span data-ttu-id="41f36-107">일반적으로 이러한 앱은 GUID 같은 식별자를 Blob 이름으로 사용하고 데이터베이스 레코드에서 이러한 식별자를 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-107">Such apps commonly use identifiers like GUIDs as blob names and reference these identifiers in database records.</span></span> <span data-ttu-id="41f36-108">앱은 데이터베이스를 사용하여 Blob이 저장되는 위치 및 Blob에 포함하는 데이터 종류를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-108">The app will use the database to determine where blobs are stored and the kind of data they contain.</span></span>

<span data-ttu-id="41f36-109">다른 앱에서는 의미 및 구조를 표시하는 데 컨테이너 및 Blob 이름이 사용되는 개인 파일 시스템 같은 Azure Blob Storage를 더 많이 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-109">Other apps may use Azure Blob storage more like a personal file system, where container and blob names are used to indicate meaning and structure.</span></span> <span data-ttu-id="41f36-110">이러한 종류의 앱에서 Blob 이름은 종종 기존 파일 이름과 같이 표시되고, `.jpg` 같은 파일 이름 확장명을 포함하여 포함된 데이터의 종류를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-110">Blob names in these kinds of apps will often look like traditional file names and include file name extensions like `.jpg` to indicate what kind of data they contain.</span></span> <span data-ttu-id="41f36-111">이러한 앱은 가상 디렉터리(아래 참조)를 사용하여 Blob을 구성하고 일반적으로 메타데이터 태그를 사용하여 Blob 및 컨테이너에 대한 정보를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-111">They'll use virtual directories (see below) to organize blobs and will frequently use metadata tags to store information about blobs and containers.</span></span>

<span data-ttu-id="41f36-112">Blob 및 컨테이너를 구성하고 저장하는 방법을 결정할 때 고려해야 하는 몇 가지 주요 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-112">There are a few key things to consider when deciding how to organize and store blobs and containers.</span></span>

### <a name="naming-limitations"></a><span data-ttu-id="41f36-113">이름 지정 제한 사항</span><span class="sxs-lookup"><span data-stu-id="41f36-113">Naming limitations</span></span>

<span data-ttu-id="41f36-114">컨테이너 및 Blob 이름은 길이 제한 및 문자 제한을 포함한 규칙 집합을 따라야 합니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-114">Container and blob names must conform to a set of rules, including length limitations and character restrictions.</span></span> <span data-ttu-id="41f36-115">이름 지정 규칙에 대한 자세한 내용은 이 모듈의 끝부분에 있는 추가 참고 자료 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="41f36-115">See the Further Reading section at the end of this module for more specific information about naming rules.</span></span>

### <a name="public-access-and-containers-as-security-boundaries"></a><span data-ttu-id="41f36-116">보안 경계인 공용 액세스 및 컨테이너</span><span class="sxs-lookup"><span data-stu-id="41f36-116">Public access and containers as security boundaries</span></span>

<span data-ttu-id="41f36-117">기본적으로 모든 Blob에 액세스하려면 인증이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-117">By default, all blobs require authentication to access.</span></span> <span data-ttu-id="41f36-118">그러나 개별 컨테이너는 인증 없이 Blob의 공용 다운로드를 허용하도록 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-118">However, individual containers can be configured to allow public downloading of their blobs without authentication.</span></span> <span data-ttu-id="41f36-119">이 기능은 정적 웹 사이트 자산 호스트 및 파일 공유와 같은 많은 사용 사례를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-119">This feature supports many use cases, such as hosting static website assets and sharing files.</span></span> <span data-ttu-id="41f36-120">Blob 콘텐츠 다운로드는 웹에서 다른 종류의 데이터를 읽는 것과 동일한 방식으로 작동하기 때문입니다. 브라우저를 가리키거나 Blob URL에서 GET 요청을 수행할 수 있는 항목을 가리키면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-120">This is because downloading blob contents works the same way as reading any other kind of data over the web: you just point a browser or anything that can make a GET request at the blob URL.</span></span>

<span data-ttu-id="41f36-121">Blob Storage에서 직접 다운로드한 데이터는 서버 쪽 앱에서 트래픽을 생성하지 않으므로 확장성을 위해 공용 액세스를 사용하도록 설정하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-121">Enabling public access is important for scalability because data downloaded directly from Blob storage doesn't generate any traffic in your server-side app.</span></span> <span data-ttu-id="41f36-122">공용 액세스를 즉시 이용하지 않거나 데이터베이스를 사용하여 응용 프로그램을 통해 데이터 액세스를 제어하는 경우에도 공개적으로 제공할 데이터에 개별 컨테이너를 사용하도록 계획합니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-122">Even if you don't immediately take advantage of public access or if you will use a database to control data access via your application, plan on using separate containers for data you want to be publicly available.</span></span>

> [!CAUTION]
> <span data-ttu-id="41f36-123">공용 액세스를 위해 구성된 컨테이너의 Blob은 해당 저장소 URL을 알고 있는 모든 사용자가 인증 또는 감사 없이 다운로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-123">Blobs in a container configured for public access can be downloaded without any kind of authentication or auditing by anyone who knows their storage URLs.</span></span> <span data-ttu-id="41f36-124">공개적으로 공유하지 않을 공용 컨테이너에 Blob 데이터를 넣지 마세요.</span><span class="sxs-lookup"><span data-stu-id="41f36-124">Never put blob data in a public container that you don't intend to share publicly.</span></span>

<span data-ttu-id="41f36-125">공용 액세스 외에도 Azure에는 컨테이너에 대한 세분화된 권한 제어를 허용하는 공유 액세스 서명 기능이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-125">In addition to public access, Azure has a shared access signature feature that allows fine-grained permissions control on containers.</span></span> <span data-ttu-id="41f36-126">정밀 액세스 제어를 사용하면 확장성을 더 개선하는 시나리오를 구현할 수 있으므로 컨테이너는 일반적으로 보안 경계로 생각하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-126">Precision access control enables scenarios that further improve scalability, so thinking about containers as security boundaries in general is a helpful guideline.</span></span>

### <a name="blob-name-prefixes-virtual-directories"></a><span data-ttu-id="41f36-127">Blob 이름 접두사(가상 디렉터리)</span><span class="sxs-lookup"><span data-stu-id="41f36-127">Blob name prefixes (virtual directories)</span></span>

<span data-ttu-id="41f36-128">기술적으로 컨테이너는 “평면”이며 중첩 또는 계층 구조를 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-128">Technically, containers are "flat" and do not support any kind of nesting or hierarchy.</span></span> <span data-ttu-id="41f36-129">그러나 파일 경로처럼 보이는 Blob 계층 구조 이름(예: `finance/budgets/2017/q1.xls`) 제공할 경우 API의 목록 작업은 특정 접두사에 대한 결과를 필터링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-129">But if you give your blobs hierarchical names that look like file paths (such as `finance/budgets/2017/q1.xls`), the API's listing operation can filter results to specific prefixes.</span></span> <span data-ttu-id="41f36-130">이렇게 하면 파일 및 폴더의 계층 구조 시스템인 것처럼 목록을 탐색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-130">This allows you to navigate the list as if it was a hierarchical system of files and folders.</span></span>

<span data-ttu-id="41f36-131">일부 도구 및 클라이언트 라이브러리가 이 기능을 사용하여 파일 시스템인 것처럼 Blob Storage를 시각화하고 탐색하기 때문에 이 기능을 ‘가상 디렉터리’라고도 합니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-131">This feature is often called *virtual directories* because some tools and client libraries use it to visualize and navigate Blob storage as if it was a file system.</span></span> <span data-ttu-id="41f36-132">각 폴더 탐색은 해당 폴더의 Blob을 나열하기 위한 별도의 호출을 트리거합니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-132">Each folder navigation triggers a separate call to list the blobs in that folder.</span></span>

<span data-ttu-id="41f36-133">Blob의 파일 이름과 같은 이름을 사용하는 것은 복잡한 Blob 데이터를 구성하고 탐색하는 일반적인 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-133">Using names that are like file names for blobs is a common technique for organizing and navigating complex blob data.</span></span>

### <a name="blob-types"></a><span data-ttu-id="41f36-134">Blob 형식</span><span class="sxs-lookup"><span data-stu-id="41f36-134">Blob types</span></span>

<span data-ttu-id="41f36-135">다음과 같이 데이터를 저장할 수 있는 세 종류의 Blob이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-135">There are three different kinds of blobs you can store data in:</span></span>

- <span data-ttu-id="41f36-136">**블록 Blob**은 개별적으로 또는 동시에 업로드될 수 있는 서로 다른 크기의 블록으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-136">**Block blobs** are composed of blocks of different sizes that can be uploaded independently and in parallel.</span></span> <span data-ttu-id="41f36-137">블록 Blob에 쓰기에는 데이터를 블록에 업로드하고 블록을 Blob에 커밋하는 작업이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-137">Writing to a block blob involves uploading data to blocks and committing them to the blob.</span></span>
- <span data-ttu-id="41f36-138">**추가 Blob**은 새 데이터 추가(기존 데이터 업데이트 또는 삭제가 아님)만 지원하는 특수 블록 Blob이지만 매우 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-138">**Append blobs** are specialized block blobs that support only appending new data (not updating or deleting existing data), but they're very efficient at it.</span></span> <span data-ttu-id="41f36-139">추가 Blob은 로그 저장 또는 스트리밍된 데이터 쓰기와 같은 시나리오에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-139">Append blobs are great for scenarios like storing logs or writing streamed data.</span></span>
- <span data-ttu-id="41f36-140">**페이지 Blob**은 임의 액세스 읽기 및 쓰기를 포함하는 시나리오를 위해 디자인되었습니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-140">**Page blobs** are designed for scenarios that involve random-access reads and writes.</span></span> <span data-ttu-id="41f36-141">페이지 Blob은 Azure Virtual Machines에서 사용되는 VHD(가상 하드 디스크) 파일을 저장하는 데 사용되지만 임의 액세스가 포함된 모든 시나리오에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-141">Page blobs are used to store the virtual hard disk (VHD) files used by Azure Virtual Machines, but they're great for any scenario that involves random access.</span></span>

<span data-ttu-id="41f36-142">블록 Blob은 특별히 추가 또는 페이지 Blob에 대한 호출을 수행하지 않는 대부분의 시나리오에 가장 적합한 선택입니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-142">Block blobs are the best choice for most scenarios that don't specifically call for append or page blobs.</span></span> <span data-ttu-id="41f36-143">해당 블록 기반 구조는 매우 빠른 업로드 및 다운로드를 지원하며, 개별 Blob 부분에 효율적으로 액세스할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-143">Their block-based structure supports very fast uploads and downloads and efficient access to individual pieces of a blob.</span></span> <span data-ttu-id="41f36-144">블록을 관리하고 커밋하는 프로세스는 대부분의 클라이언트 라이브러리에 의해 자동으로 처리되며 일부 클라이언트 라이브러리는 성능을 최대화하기 위해 병렬 업로드 및 다운로드도 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="41f36-144">The process of managing and committing blocks is automatically handled by most client libraries, and some will also handle parallel uploads and downloads to maximize performance.</span></span>