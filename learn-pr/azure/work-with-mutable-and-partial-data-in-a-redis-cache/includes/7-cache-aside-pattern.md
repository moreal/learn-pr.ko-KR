<span data-ttu-id="47d05-101">응용 프로그램을 빌드할 때 뛰어난 사용자 환경을 제공하려고 하며, 그 중 일부는 빠른 데이터 검색입니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-101">When building an application, you want to provide a great user experience, and a part of that is quick data retrieval.</span></span> <span data-ttu-id="47d05-102">데이터베이스에서 데이터를 검색하는 것은 일반적으로 느린 프로세스입니다. 데이터를 자주 읽는 경우 이로 인해 사용자 환경이 좋지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-102">Retrieving data from a database is typically a slow process, and if this data is read often, this could provide a poor user experience.</span></span> <span data-ttu-id="47d05-103">캐시 배제 패턴은 데이터베이스와 함께 캐시를 구현하여 가장 자주 액세스하는 데이터를 최대한 빨리 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-103">The cache-aside pattern describes how you can implement a cache in conjunction with a database, to return the most commonly accessed data as quickly as possible.</span></span>

<span data-ttu-id="47d05-104">여기서는 중요한 데이터에 빠르게 액세스할 수 있도록 캐시 배제 패턴을 사용하는 방법에 대해 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-104">Here, you'll learn how the cache-aside pattern can be used to ensure your important data is quickly accessible.</span></span>

## <a name="what-is-the-cache-aside-pattern"></a><span data-ttu-id="47d05-105">캐시 배제 패턴이란?</span><span class="sxs-lookup"><span data-stu-id="47d05-105">What is the cache-aside pattern?</span></span>

<span data-ttu-id="47d05-106">캐시 배제 패턴은 관계형 데이터베이스와 같은 데이터 원본에서 데이터를 검색해야 하는 경우 먼저 캐시의 데이터를 확인해야 함을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-106">The cache-aside pattern dictates that when you need to retrieve data from a data source, like a relational database, you should first check for the data in your cache.</span></span> <span data-ttu-id="47d05-107">데이터가 캐시에 있으면 해당 데이터를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-107">If the data is in your cache, use it.</span></span> <span data-ttu-id="47d05-108">데이터가 캐시에 없으면 데이터베이스를 쿼리하고, 사용자에게 데이터를 다시 반환하면 캐시에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-108">If the data is not in your cache, then query the database, and when you're returning the data back to the user, add it to your cache.</span></span> <span data-ttu-id="47d05-109">이렇게 하면 다음에 데이터가 필요할 때 캐시에서 데이터에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-109">This will then allow you to access the data from your cache the next time it's needed.</span></span>

## <a name="when-to-implement-the-cache-aside-pattern"></a><span data-ttu-id="47d05-110">캐시 배제 패턴은 언제 구현하나요?</span><span class="sxs-lookup"><span data-stu-id="47d05-110">When to implement the cache-aside pattern?</span></span>

<span data-ttu-id="47d05-111">데이터베이스에서 데이터 읽기는 일반적으로 느린 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-111">Reading data from a database is usually a slow process.</span></span> <span data-ttu-id="47d05-112">이 프로세스에는 복잡한 쿼리를 컴파일하고, 쿼리 실행 계획을 준비하고, 쿼리를 실행한 다음, 결과를 준비하는 과정이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-112">It involves compilation of a complex query, preparation of a query execution plan, execution of the query, and then preparation of the result.</span></span> <span data-ttu-id="47d05-113">이 프로세스는 경우에 따라 디스크에서 데이터를 읽을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-113">In some cases, this process may read data from the disk as well.</span></span> <span data-ttu-id="47d05-114">쿼리를 미리 컴파일하고 일부 데이터를 메모리에 로드하는 것처럼 데이터베이스 수준에서 수행할 수 있는 최적화가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-114">There are optimizations that can be done on the database level, like pre-compiling the queries, and loading some of the data in memory.</span></span> <span data-ttu-id="47d05-115">그러나 데이터베이스에서 데이터를 검색하는 경우 항상 쿼리를 실행하고 결과를 준비해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-115">However, execution of the query and preparation of the result will always happen when retrieving data from a database.</span></span>

<span data-ttu-id="47d05-116">이 문제는 캐시 배제 패턴을 사용하여 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-116">We can solve this problem by using the cache-aside pattern.</span></span> <span data-ttu-id="47d05-117">캐시 배제 패턴에는 여전히 응용 프로그램과 데이터베이스가 있지만 이제는 캐시도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-117">In the cache-aside pattern, we still have the application and the database, but now we also have a cache.</span></span> <span data-ttu-id="47d05-118">캐시는 데이터를 메모리에 저장하므로 파일 시스템과 상호 작용할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-118">A cache stores its data in memory, so it doesn't have to interact with the file system.</span></span> <span data-ttu-id="47d05-119">또한 캐시는 키 값 쌍과 같이 매우 간단한 데이터 구조로 데이터를 저장하므로 데이터를 쓸 때 복잡한 쿼리를 실행하여 데이터를 수집하거나 인덱스를 유지 관리할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-119">Caches also store data in very simple data structures, like key value pairs, so they don't have to execute complex queries to gather data or maintain indexes when writing data.</span></span> <span data-ttu-id="47d05-120">이로 인해 캐시는 일반적으로 데이터베이스보다 성능이 우수합니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-120">Because of this, a cache is typically more performant than a database.</span></span> <span data-ttu-id="47d05-121">응용 프로그램을 사용하면 먼저 캐시에서 데이터를 읽으려고 시도합니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-121">When you use an application, it will try to read data from the cache first.</span></span> <span data-ttu-id="47d05-122">요청한 데이터가 캐시에 없는 경우 항상 그랬듯이 응용 프로그램이 데이터베이스에서 해당 데이터를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-122">If the requested data is not in the cache, the application will retrieve it from the database, like it always has done.</span></span> <span data-ttu-id="47d05-123">하지만 그런 후에는 이후 요청에 대비하여 데이터를 캐시에 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-123">However, then it stores the data in the cache for subsequent requests.</span></span> <span data-ttu-id="47d05-124">다음 번에 사용자가 데이터를 요청하면 캐시에서 직접 데이터를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-124">Next time when any user requests the data, it will return it from the cache directly.</span></span>

![캐시에 데이터를 로드하는 다이어그램](../media/8-cache-aside-set-cache.png)

### <a name="how-to-manage-updating-data"></a><span data-ttu-id="47d05-126">데이터 업데이트를 관리하는 방법</span><span class="sxs-lookup"><span data-stu-id="47d05-126">How to manage updating data</span></span>

<span data-ttu-id="47d05-127">캐시 배제 패턴을 구현하는 경우 작은 문제가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-127">When you implement the cache-aside pattern, you introduce a small problem.</span></span> <span data-ttu-id="47d05-128">이제는 데이터가 캐시와 데이터 저장소에 저장되므로 업데이트하려고 할 때 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-128">Since your data is now stored in a cache and a data store, you can run into problems when you try to make an update.</span></span> <span data-ttu-id="47d05-129">예를 들어 데이터를 업데이트하려면 캐시와 데이터 저장소를 모두 업데이트해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-129">For example, to update your data, you would need to update both the cache and the data store.</span></span>

<span data-ttu-id="47d05-130">캐시 배제 패턴에서 이 문제를 해결하는 방법은 캐시의 데이터를 무효화하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-130">The solution to this problem in the cache-aside pattern is to invalidate the data in the cache.</span></span> <span data-ttu-id="47d05-131">응용 프로그램에서 데이터를 업데이트하는 경우 먼저 캐시의 데이터를 삭제한 다음, 데이터 원본을 직접 변경해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-131">When you update data in your application, you should first delete the data in the cache and then make the changes to the data source directly.</span></span> <span data-ttu-id="47d05-132">이렇게 하면 다음 번에 데이터를 요청할 때 해당 데이터가 캐시에 표시되지 않고 프로세스가 반복됩니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-132">By doing this, next time the data is requested, it won't be present in the cache, and the process will repeat.</span></span> 

![캐시된 데이터를 무효화하는 다이어그램](../media/8-cache-aside-invalidate.png)

## <a name="considerations-for-using-the-cache-aside-pattern"></a><span data-ttu-id="47d05-134">캐시 배제 패턴 사용 시 고려 사항</span><span class="sxs-lookup"><span data-stu-id="47d05-134">Considerations for using the cache-aside pattern</span></span>

<span data-ttu-id="47d05-135">캐쉬에 저장할 데이터를 신중하게 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-135">Carefully consider which data to put in the cache.</span></span> <span data-ttu-id="47d05-136">일부 데이터를 캐시하기에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-136">Not all data is suitable to be cached.</span></span>

- <span data-ttu-id="47d05-137">**수명**: 캐시 배제를 유효하게 하려면 만료 정책이 데이터의 액세스 빈도와 일치해야 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-137">**Lifetime**: For cache-aside to be effective, make sure that the expiration policy matches the access frequency of the data.</span></span> <span data-ttu-id="47d05-138">만료 기간을 너무 짧게 설정하면 응용 프로그램이 데이터 저장소에서 데이터를 지속적으로 검색하여 캐시에 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-138">Making the expiration period too short can cause applications to continually retrieve data from the data store and add it to the cache.</span></span>

- <span data-ttu-id="47d05-139">**제거**: 캐시는 일반적인 데이터 저장소에 비해 크기가 제한되며 필요한 경우 데이터를 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-139">**Evicting**: Caches have a limited size compared to typical data stores, and they'll evict data if necessary.</span></span> <span data-ttu-id="47d05-140">데이터에 적절한 제거 정책을 선택해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-140">Make sure you choose an appropriate eviction policy for your data.</span></span>

- <span data-ttu-id="47d05-141">**초기화**: 캐시 배제 패턴을 효과적으로 만들려면 많은 솔루션에서 자주 액세스할 것으로 생각되는 데이터로 캐시를 미리 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-141">**Priming**: To make the cache-aside pattern effective, many solutions will prepopulate the cache with data that they think will be accessed often.</span></span>

- <span data-ttu-id="47d05-142">**일관성**: 캐시 배제 패턴을 구현한다고 해서 데이터 저장소와 캐시 간의 일관성을 보장하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-142">**Consistency**: Implementing the cache-aside pattern doesn't guarantee consistency between the data store and the cache.</span></span> <span data-ttu-id="47d05-143">데이터 저장소의 데이터는 캐시에 알리지 않고 변경될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-143">Data in a data store can be changed without notifying the cache.</span></span> <span data-ttu-id="47d05-144">이로 인해 심각한 동기화 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-144">This can lead to serious synchronization issues.</span></span>

<span data-ttu-id="47d05-145">캐시 배제 패턴은 디스크를 사용하는 데이터 원본에서 데이터에 자주 액세스해야 하는 경우에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-145">The cache-aside pattern is useful when you're required to access data frequently from a data source that uses a disk.</span></span> <span data-ttu-id="47d05-146">캐시 배제 패턴을 사용하면 중요한 데이터를 캐시에 저장하여 검색 속도를 높일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="47d05-146">Using the cache-aside pattern, you'll store important data in a cache to help increase the speed of retrieving it.</span></span> 