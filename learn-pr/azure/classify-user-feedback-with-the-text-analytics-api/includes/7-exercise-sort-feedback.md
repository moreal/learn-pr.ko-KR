모든 함수에만 하나의 트리거가 있어야 합니다. 코드 실행 되도록 트리거되는 방법을 정의 합니다. 트리거를 외에도 우리 데이터 원본에 연결 하는 바인딩을 정의할 수 있습니다. 솔루션의 다이어그램에서 기억 하는 경우에 세 개의 큐에 메시지를 보낼 하고자 합니다. 따라서 정의 이러한 연결 출력 바인딩으로 함수에서입니다. 통해 이러한 바인딩을 만들 수는 **출력 바인딩을** UI입니다. 그러나 시간을 절약 하려면에서는에서는 구성 파일을 직접 편집 합니다.

1. 이 함수를 선택 [!INCLUDE [func-name-discover](./func-name-discover.md)], 함수 앱 포털에서 합니다.

1. 확장 된 **파일을 볼** 화면 오른쪽의 메뉴.

1. 아래는 **파일을 볼** 탭을 선택 **function.json** 를 편집기에서 구성 파일을 엽니다.

1. 다음 JSON을 사용 하 여 구성 파일의 전체 콘텐츠를 대체 합니다.

[!code-json[](../code/function.json)]

구성에 세 개의 새 바인딩을 추가 했습니다.

- 형식입니다. 각 새 바인딩을 `queue`합니다. 이러한 바인딩은 피드백의 감정을 알게 되 면이 피드백 메시지를 사용 하 여 채웁니다 됩니다 하는 세 개의 큐입니다.
- 각 바인딩에 방향으로 정의 `out`가 이러한 큐에 메시지를 게시 합니다.
- 각 바인딩은 동일한 저장소 계정 연결을 사용합니다.
- 각 바인딩에 고유한 `queueName` 고 `name`입니다.

예를 들어 말했다는 거 야 하는 것 만큼 쉽습니다는 큐에 메시지 게시 `context.bindings.negativeFeedbackQueueItem = "<message>"`합니다.

## <a name="update-implementation-to-sort-feedback-into-queues-based-on-sentiment-score"></a>감정 점수를 기준으로 큐에 피드백을 정렬 하려면 업데이트 구현

버킷 3 개, 중립, 양수와 음수에 피드백을 정렬 하는 피드백 비교의 목표가입니다. 지금 코드 텍스트 분석 API를 호출 하는 입력된 큐 있고이 출력 큐 정의 했습니다. 이 섹션에서는 인지에 따라 해당 큐에 메시지를 이동 하는 논리를 추가 합니다.

1. 이 함수를 이동할 [!INCLUDE [func-name-discover](./func-name-discover.md)]를 연 `index.js` 다시 코드 편집기에서.

1. 다음 업데이트 구현을으로 바꿉니다.

[!code-javascript[](../code/discover-sentiment+sort.js?highlight=25-48)]

구현으로 강조 표시 된 코드를 추가 했습니다. 코드에는 Text Analytics API cognitive 서비스의에서 응답을 구문 분석합니다. 감정 점수를 기준으로 메시지 중 하나에 전달 되거나 3 개의 출력 큐입니다. 메시지를 게시 하는 코드는 방금 올바른 바인딩 매개 변수를 설정 합니다.

## <a name="try-it-out"></a>체험

업데이트 된 구현을 테스트 하려면 저장소 탐색기로 이동 하겠습니다 했습니다.

1. 리소스 그룹으로 이동 합니다 **리소스 그룹** 포털의 섹션입니다.

1. 이 단원에 사용 되는 리소스 그룹을 선택 합니다.

1. 에 **리소스 그룹** 패널이 열립니다. 그러면 저장소 계정 항목을 찾아 선택 합니다.
    ![스크린 샷 저장소 계정 리소스 그룹 창에서 선택 합니다.](../media/select-storage-account.png)

1. 선택 **저장소 탐색기 (미리 보기)** 주 저장소 계정 창의 왼쪽된 메뉴에서.  이 작업은 포털 내부에서 Azure Storage 탐색기를 엽니다. 화면은이 단계에서 다음 스크린샷과 같이 표시 됩니다.
    ![Storage 탐색기를 현재 큐를 사용 하 여이 저장소 계정을 보여 주는 스크린샷.](../media/storage-explorer-menu-inputq.png)

아래에 나열 된 하나의 큐에 있다고 합니다 **큐** 컬렉션입니다. 이 큐가 [!INCLUDE [input-q](./q-name-input.md)], 모듈의 이전 테스트 섹션에 정의 된 입력된 큐입니다.

1. 선택 [!INCLUDE [input-q](./q-name-input.md)] 이 큐에 대 한 데이터 탐색기를 보려면 왼쪽 메뉴에서. 예상 대로 큐에 데이터가 없습니다. 사용 하 여 큐 메시지를 추가 해 보겠습니다 합니다 **메시지 추가** 창의 맨 위에 있는 명령입니다.

1. 에 **메시지 추가** 대화 상자에서 "재미이 연습을 사용 하 여!"를 입력 합니다. 에 **메시지 텍스트** 필드를 클릭 **확인** 대화 상자의 맨 아래에 있습니다.

1. 메시지에 대 한 데이터 창에 표시 됩니다 [!INCLUDE [input-q](./q-name-input.md)]합니다. 몇 초 후 클릭 **새로 고침** 큐 보기를 새로 고치려면 데이터 뷰의 맨 위에 있는 합니다. 잠시 후이 메시지가 사라집니다 있는지 확인 합니다. 따라서 되었나요?

1. 마우스 오른쪽 단추로 클릭 합니다 **큐** 왼쪽 메뉴에서 수집 합니다. 확인 된 *새* 큐 나타났습니다.
    ![컬렉션에 새 큐를 보여 주는 스크린 샷의 Storage 탐색기를 만들었습니다. 큐에 하나의 메시지가 있습니다.](../media/sa-new-output-q.png)

큐 [!INCLUDE [positive-q](./q-name-positive.md)] 메시지를 처음으로 게시 될 때 자동으로 생성 되었습니다. Azure Functions 큐 출력 바인딩을 사용 하 여 출력 큐에 게시 하기 전에 수동으로 만들 필요가 없습니다! 들어오는 메시지에는 함수에 의해 정렬 된 것을 볼 했으므로 [!INCLUDE [positive-q](./q-name-positive.md)], 여기서 다음 메시지 land를 확인해 보겠습니다.

1. 다음 메시지를 추가 위와 동일한 단계를 사용 하 여 [!INCLUDE [input-q](./q-name-input.md)]입니다.

- "저는 broccoli!"
- "Microsoft는 회사는"

1. 클릭 **새로 고침** 때까지 [!INCLUDE [input-q](./q-name-input.md)] 다시 한 번 비어 있습니다. 이 프로세스는 몇 분 정도 걸릴 수도 있으며, 몇 가지 새로 고침 필요 수 있습니다.

1. 마우스 오른쪽 단추로 클릭 합니다 **큐** 컬렉션 표시 되는 두 개의 자세한 큐를 확인 합니다. 큐 이름은 [!INCLUDE [neutral-q](./q-name-neutral.md)] 고 [!INCLUDE [negative-q](./q-name-negative.md)]입니다. 따라서 새로 고침을 계속, 몇 초 정도 걸릴 수 있습니다이 **큐** 새 큐까지 컬렉션입니다. 완료 되 면 큐 목록에는 다음과 같습니다.

![Storage 탐색기의 스크린샷 메뉴 큐 컬렉션에 있는 네 개의 큐를 표시 합니다.](../media/sa-final-q-list.png)

각 큐 메시지가 있는지 확인 하려면 목록에서를 클릭 합니다. 제안 된 메시지를 추가한 경우에 하나의 메시지가 나타납니다 [!INCLUDE [positive-q](./q-name-positive.md)], [!INCLUDE [neutral-q](./q-name-neutral.md)], 및 [!INCLUDE [negative-q](./q-name-negative.md)]합니다.

축하합니다. 이제 작업 피드백 비교를 했습니다! 입력된 큐에 메시지가 도착할 때,이 함수는 감정 점수를 가져오려고 Text Analytics API 서비스를 사용 합니다. 함수는 점수를 기준으로 적절 한 큐에 메시지를 전달 합니다. 처럼 보이지만 함수 프로세스 큐 항목을 하나만 동시에 Azure Functions 런타임은 실제로 큐 항목의 일괄 처리를 읽기를 병렬로 처리 하는 함수의 다른 인스턴스를 스핀업 합니다.