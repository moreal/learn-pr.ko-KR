<span data-ttu-id="48358-101">배포된 음악 공유 응용 프로그램의 아키텍처를 계획한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="48358-101">Suppose you are planning the architecture of a distributed music-sharing application.</span></span> <span data-ttu-id="48358-102">응용 프로그램이 가능한 한 안정적으로 확장성이 있는지 확인하고 Azure 기술을 사용하여 강력한 통신 인프라를 구축하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="48358-102">You want to ensure that the application is as reliable and scalable as possible and you intend to use Azure technologies to build a robust communication infrastructure.</span></span>

<span data-ttu-id="48358-103">올바른 Azure 기술을 선택하기 전에 응용 프로그램의 구성 요소가 교환하는 각 통신을 살펴봐야 합니다.</span><span class="sxs-lookup"><span data-stu-id="48358-103">Before you can choose the right Azure technology, you must understand each individual communication that the components of the application exchange.</span></span> <span data-ttu-id="48358-104">각 통신에 서로 다른 Azure 기술을 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="48358-104">For each communication you can choose a different Azure technology.</span></span>

<span data-ttu-id="48358-105">처음 살펴봐야 할 통신 관련 내용은 메시지나 이벤트를 보낼지 여부입니다.</span><span class="sxs-lookup"><span data-stu-id="48358-105">The first thing to understand about a communication is whether it sends messages or events.</span></span> <span data-ttu-id="48358-106">일부 Azure 기술은 이벤트를 대상으로 하고 다른 기술은 메시지를 대상으로 하므로 이 선택은 기본적인 선택입니다.</span><span class="sxs-lookup"><span data-stu-id="48358-106">Some Azure technologies target events and other target messages so this is a fundamental choice.</span></span>

## <a name="what-is-a-message"></a><span data-ttu-id="48358-107">메시지란?</span><span class="sxs-lookup"><span data-stu-id="48358-107">What is a message?</span></span>

<span data-ttu-id="48358-108">배포 응용 프로그램의 용어에서 **메시지**의 특성은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="48358-108">In the terminology of distributed applications, **messages** have the following characteristics:</span></span>

- <span data-ttu-id="48358-109">메시지에는 한 구성 요소가 생성하고 또 다른 구성 요소가 사용할 원시 데이터가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="48358-109">A message contains raw data, produced by one component, that will be consumed by another component.</span></span>
- <span data-ttu-id="48358-110">메시지에는 해당 데이터에 대한 단지 참조가 아닌 데이터 자체가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="48358-110">A message contains the data itself, not just a reference to that data.</span></span>
- <span data-ttu-id="48358-111">발신 구성 요소는 대상 구성 요소가 메시지 콘텐츠를 특정 방법으로 처리할 것으로 예상합니다.</span><span class="sxs-lookup"><span data-stu-id="48358-111">The sending component expects the message content to be processed in a certain way by the destination component.</span></span> <span data-ttu-id="48358-112">전체 시스템의 무결성은 특정 작업을 수행하는 발신자와 수신자에 따라 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="48358-112">The integrity of the overall system may depend on both sender and receiver doing a specific job.</span></span>

<span data-ttu-id="48358-113">예를 들어 사용자가 모바일 음악 공유 앱을 사용하여 새 노래를 업로드한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="48358-113">For example, suppose a user uploads a new song by using the mobile music-sharing app.</span></span> <span data-ttu-id="48358-114">모바일 앱은 Azure에서 실행되는 웹 API로 해당 노래를 보내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="48358-114">The mobile app must send that song to the web API that runs in Azure.</span></span> <span data-ttu-id="48358-115">새 노래가 추가되었음을 나타내는 단지 알림이 아닌 노래 미디어 파일 자체를 보내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="48358-115">The song media file itself must be sent, not just an alert that indicates that a new song has been added.</span></span> <span data-ttu-id="48358-116">모바일 앱은 웹 API가 데이터베이스에 새 노래를 저장하고 다른 사용자에게 제공할 것으로 예상합니다.</span><span class="sxs-lookup"><span data-stu-id="48358-116">The mobile app expects that the web API will store the new song in the database and make it available to other users.</span></span> <span data-ttu-id="48358-117">이는 메시지의 예입니다.</span><span class="sxs-lookup"><span data-stu-id="48358-117">This is an example of a message.</span></span>

## <a name="what-is-an-event"></a><span data-ttu-id="48358-118">이벤트란?</span><span class="sxs-lookup"><span data-stu-id="48358-118">What is an event?</span></span>

<span data-ttu-id="48358-119">**이벤트**는 메시지보다 간단하고 브로드캐스트 통신에 가장 자주 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="48358-119">**Events** are lighter-weight than messages and are most often used for broadcast communications.</span></span> <span data-ttu-id="48358-120">이벤트를 보내는 구성 요소는 **게시자**라고 하고 수신자는 **구독자**라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="48358-120">The components sending the event are known as **publishers** and receivers are known as **subscribers**.</span></span>

<span data-ttu-id="48358-121">일반적으로 수신 구성 요소는 이벤트를 통해 관심이 있는 통신을 결정하고 해당 통신을 “구독”합니다.</span><span class="sxs-lookup"><span data-stu-id="48358-121">With events, receiving components will generally decide in which communications they are interested and "subscribe" to those.</span></span> <span data-ttu-id="48358-122">일반적으로 구독은 Azure Event Grid 또는 Azure Event Hub와 같은 중개자에서 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="48358-122">The subscription is usually managed by an intermediary like Azure Event Grid or Azure Event Hub.</span></span> <span data-ttu-id="48358-123">게시자가 이벤트를 보내면 중개자는 해당 이벤트를 관심 있는 구독자에게 라우팅합니다.</span><span class="sxs-lookup"><span data-stu-id="48358-123">When publishers send an event, the intermediary will route that event to interested subscribers.</span></span> <span data-ttu-id="48358-124">이를 “게시-구독 아키텍처”라고 하며 이벤트를 처리하는 유일한 방법이 아니라 가장 일반적인 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="48358-124">This is known as a "publish-subscribe architecture", it is not the only way to deal with events, but it is the most common.</span></span>

<span data-ttu-id="48358-125">이벤트의 특성은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="48358-125">Events have the following characteristics:</span></span>

- <span data-ttu-id="48358-126">이벤트는 어떤 것이 발생했음을 나타내는 간단한 알림입니다.</span><span class="sxs-lookup"><span data-stu-id="48358-126">An event is a lightweight notification that indicates that something happened.</span></span>
- <span data-ttu-id="48358-127">이벤트가 여러 수신자에게 발신되거나 전혀 발신되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="48358-127">The event may be sent to multiple receivers or to none at all.</span></span>
- <span data-ttu-id="48358-128">이벤트는 종종 각 게시자에 대한 다수의 구독자를 “팬아웃”하거나 포함해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="48358-128">Events are often intended to "fan-out" or have a large number of subscribers for each publisher.</span></span>
- <span data-ttu-id="48358-129">이벤트 게시자는 수신 구성 요소가 수행하는 작업에 대한 기대가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="48358-129">The publisher of the event has no expectation about the action a receiving component takes.</span></span>
- <span data-ttu-id="48358-130">일부 이벤트는 개별 단위이며 다른 이벤트와 관련이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="48358-130">Some events are discrete units and unrelated to other events.</span></span> 
- <span data-ttu-id="48358-131">일부 이벤트는 관련되고 정렬된 시리즈의 일부입니다.</span><span class="sxs-lookup"><span data-stu-id="48358-131">Some events are part of a related and ordered series.</span></span>  

<span data-ttu-id="48358-132">예를 들어 음악 파일 업로드가 완료되었고 새 노래가 데이터베이스에 추가되었다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="48358-132">For example, suppose the music file upload has been completed and the new song has been added to the database.</span></span> <span data-ttu-id="48358-133">새 파일 정보를 사용자에게 알리기 위해 웹 API는 웹 프런트 엔드 및 모바일 앱 사용자에게 새 파일 정보를 알려야 합니다.</span><span class="sxs-lookup"><span data-stu-id="48358-133">In order to inform users of the new file, the web API must inform the web front-end and mobile app users of the new file.</span></span> <span data-ttu-id="48358-134">사용자가 새로운 노래를 들을지 여부를 선택할 수 있으므로, 초기 알림에는 음악 파일을 포함하지 않고 사용자에게 노래가 존재함을 알리면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="48358-134">The users can choose whether to listen to the new song, so the initial notification does not include the music file but only notifies users that the song exists.</span></span> <span data-ttu-id="48358-135">발신자는 이벤트 수신자가 이 이벤트 수신의 응답으로 특별히 어떤 작업을 수행할 것으로 기대하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="48358-135">The sender does not have a specific expectation that the event receivers will do anything particular in response the receiving this event.</span></span>

<span data-ttu-id="48358-136">이는 개별 이벤트의 예입니다.</span><span class="sxs-lookup"><span data-stu-id="48358-136">This is an example of a discrete event.</span></span>

## <a name="how-to-choose-messages-or-events"></a><span data-ttu-id="48358-137">메시지 또는 이벤트 선택 방법</span><span class="sxs-lookup"><span data-stu-id="48358-137">How to choose messages or events</span></span>

<span data-ttu-id="48358-138">단일 응용 프로그램에서 일부 용도에 이벤트를 사용하고 다른 용도에 메시지를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="48358-138">A single application is likely to use events for some purposes and messages for others.</span></span> <span data-ttu-id="48358-139">선택하기 전에 응용 프로그램 아키텍처와 모든 사용 사례를 분석하여 구성 요소가 서로 통신해야 하는 다양한 용도를 모두 파악해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="48358-139">Before you choose, you must analyze your application architecture and all its use cases to identify all the different purposes its components have to communicate with each other.</span></span> 

<span data-ttu-id="48358-140">이벤트는 브로드캐스트에 사용할 가능성이 더 크고 종종 삭제되므로 현재 구독자가 없는 경우 통신이 수신자에 의해 처리되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="48358-140">Events are more likely to be used for broadcasts and are often ephemeral, meaning a communication might not be handled by any receiver if none are currently subscribing.</span></span> <span data-ttu-id="48358-141">배포 응용 프로그램에 통신이 처리된다는 보장이 필요한 경우에는 메시지가 사용될 가능성이 더 큽니다.</span><span class="sxs-lookup"><span data-stu-id="48358-141">Messages are more likely to be used where the distributed application requires a guarantee that the communication will be processed.</span></span>

<span data-ttu-id="48358-142">각 통신에 대한 다음 질문을 고려하세요. 발신 구성 요소는 대상 구성 요소가 통신을 특정 방법으로 처리할 것으로 예상하나요?</span><span class="sxs-lookup"><span data-stu-id="48358-142">For each communication consider the question: Does the sending component expect the communication to be processed in a particular way by the destination component?</span></span>

<span data-ttu-id="48358-143">대답이 예이면 메시지를 사용하도록 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="48358-143">If the answer is yes, choose to use a message.</span></span> <span data-ttu-id="48358-144">대답이 아니요면 이벤트를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="48358-144">If the answer is no, you may be able to use events.</span></span>

## <a name="summary"></a><span data-ttu-id="48358-145">요약</span><span class="sxs-lookup"><span data-stu-id="48358-145">Summary</span></span>

<span data-ttu-id="48358-146">배포 응용 프로그램의 구성 요소는 다양한 용도로 서로 통신합니다.</span><span class="sxs-lookup"><span data-stu-id="48358-146">The components of a distributed application communicate with each other for many different purposes.</span></span> <span data-ttu-id="48358-147">용도에 맞게 디자인된 Azure 기술을 선택할 수 있도록 해당 용도별로 이벤트 또는 메시지를 사용할지 선택해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="48358-147">For each of these purposes, you must choose whether to use events or messages so that you can choose an Azure technology that is designed for that purpose.</span></span> 

<span data-ttu-id="48358-148">구성 요소가 통신하는 이유와 이벤트 또는 메시지를 사용할지 여부를 파악한 경우, 계속해서 Azure Storage 큐, Event Hub, Event Grid 또는 Service Bus 중에서 선택하여 정보를 교환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="48358-148">Having understood why your components communicate and whether they use events or messages, you can proceed to choose from Azure Storage queues, Event Hubs, Event Grids, or Service Bus to exchange the information.</span></span>