<span data-ttu-id="a1e71-101">서버리스 컴퓨팅이 적합한지 여부를 결정하는 데 도움이 되도록 먼저 서버리스의 개념을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-101">To help decide whether serverless computing is right for you, let's first learn what serverless is all about.</span></span>

## <a name="what-is-serverless-compute"></a><span data-ttu-id="a1e71-102">서버리스 계산이란?</span><span class="sxs-lookup"><span data-stu-id="a1e71-102">What is serverless compute?</span></span>

<span data-ttu-id="a1e71-103">서버리스 계산은 FaaS(Function as a Service) 또는 클라우드 플랫폼에서 호스트되는 마이크로 서비스로 간주할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-103">Serverless compute can be thought of as a function as a service (FaaS), or a microservice that is hosted on a cloud platform.</span></span> <span data-ttu-id="a1e71-104">비즈니스 논리가 함수로 실행되며 인프라를 수동으로 프로비전하거나 크기를 조정할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-104">Your business logic runs as functions and you don't have to manually provision or scale infrastructure.</span></span> <span data-ttu-id="a1e71-105">클라우드 공급자가 인프라를 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-105">The cloud provider manages infrastructure.</span></span> <span data-ttu-id="a1e71-106">부하에 따라 앱이 자동으로 확장되거나 축소됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-106">Your app is automatically scaled out or down depending on load.</span></span> <span data-ttu-id="a1e71-107">Azure에는 이 유형의 아키텍처를 빌드하는 여러 가지 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-107">Azure has several ways to build this sort of architecture.</span></span> <span data-ttu-id="a1e71-108">가장 일반적인 두 가지 방법은 이 모듈에서 집중적으로 살펴볼 Azure Logic Apps 및 Azure Functions입니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-108">The two most common approaches are Azure Logic Apps and Azure Functions, which we focus on in this module.</span></span>

## <a name="what-is-azure-functions"></a><span data-ttu-id="a1e71-109">Azure Functions란?</span><span class="sxs-lookup"><span data-stu-id="a1e71-109">What is Azure Functions?</span></span>

<span data-ttu-id="a1e71-110">Azure Functions는 서버리스 응용 프로그램 플랫폼입니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-110">Azure Functions is a serverless application platform.</span></span> <span data-ttu-id="a1e71-111">이를 통해 개발자는 인프라를 프로비전하지 않고도 실행할 수 있는 비즈니스 논리를 호스트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-111">It allows developers to host business logic that can be executed without provisioning infrastructure.</span></span> <span data-ttu-id="a1e71-112">Functions는 기본적으로 확장성을 제공하고 사용된 리소스에 대한 요금만 부과합니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-112">Functions provides intrinsic scalability and you are charged only for the resources used.</span></span> <span data-ttu-id="a1e71-113">C#, F# 및 JavaScript를 포함하여 선택한 언어로 함수 코드를 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-113">You can write your function code in the language of your choice, including C#, F#, and JavaScript.</span></span> <span data-ttu-id="a1e71-114">NuGet 및 NPM에 대한 지원도 포함되므로 비즈니스 논리에서 인기 있는 라이브러리를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-114">Support for NuGet and NPM is also included, so you can use popular libraries in your business logic.</span></span>

## <a name="benefits-of-a-serverless-compute-solution"></a><span data-ttu-id="a1e71-115">서버리스 계산 솔루션의 이점</span><span class="sxs-lookup"><span data-stu-id="a1e71-115">Benefits of a serverless compute solution</span></span>

<span data-ttu-id="a1e71-116">서버리스 계산은 클라우드에서 비즈니스 논리 코드를 호스트하는 훌륭한 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-116">Serverless compute is a great option for hosting business logic code in the cloud.</span></span> <span data-ttu-id="a1e71-117">Azure Functions와 같은 서버리스 제품을 사용하면 선택한 언어로 비즈니스 논리를 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-117">With serverless offerings such as Azure Functions, you can write your business logic in the language of your choice.</span></span> <span data-ttu-id="a1e71-118">자동 크기 조정을 사용할 수 있고, 서버를 관리할 필요가 없으며, 예약된 시간이 아닌 사용된 양에 따라 요금이 부과됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-118">You get automatic scaling, you have no servers to manage, and you are charged based on what is used — not on reserved time.</span></span> <span data-ttu-id="a1e71-119">다음은 고려해야 하는 서버리스 솔루션의 몇 가지 추가 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-119">Here are some additional characteristics of a serverless solution for you to consider.</span></span>

### <a name="avoids-over-allocation-of-infrastructure"></a><span data-ttu-id="a1e71-120">인프라 초과 할당 없음</span><span class="sxs-lookup"><span data-stu-id="a1e71-120">Avoids over-allocation of infrastructure</span></span>

<span data-ttu-id="a1e71-121">VM 서버를 프로비전하고 최고 로드 시간을 처리하기에 충분한 리소스로 구성했다고 가정하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-121">Suppose you've provisioned VM servers and configured them with enough resources to handle your peak load times.</span></span> <span data-ttu-id="a1e71-122">부하가 적은 경우에는 사용하지 않는 인프라에 대해 요금을 지불할 가능성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-122">When the load is light, you are potentially paying for infrastructure you're not using.</span></span> <span data-ttu-id="a1e71-123">서버리스 컴퓨팅은 자동으로 크기를 확장 및 축소하여 할당 문제를 해결하는 데 유용하며, 함수가 작업을 처리할 때만 요금이 청구됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-123">Serverless computing helps solve the allocation problem by scaling up or down automatically, and you're only billed when your function is processing work.</span></span>

### <a name="stateless-logic"></a><span data-ttu-id="a1e71-124">상태 비저장 논리</span><span class="sxs-lookup"><span data-stu-id="a1e71-124">Stateless logic</span></span>

<span data-ttu-id="a1e71-125">상태 비저장 함수는 서버리스 계산을 위한 좋은 후보입니다. 함수 인스턴스는 요청 시 생성되고 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-125">Stateless functions are great candidates for serverless compute; function instances are created and destroyed on demand.</span></span> <span data-ttu-id="a1e71-126">상태가 필요한 경우 연관된 저장소 서비스에 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-126">If state is required, it can be stored in an associated storage service.</span></span>

### <a name="event-driven"></a><span data-ttu-id="a1e71-127">이벤트 기반</span><span class="sxs-lookup"><span data-stu-id="a1e71-127">Event driven</span></span>

<span data-ttu-id="a1e71-128">함수는 ‘이벤트를 기반’으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-128">Functions are _event driven_.</span></span> <span data-ttu-id="a1e71-129">이는 HTTP 요청 또는 큐에 메시지 추가 등의 이벤트(“트리거”라고 함)에 응답해서만 실행됨을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-129">This means they run only in response to an event (called a "trigger"), such as receiving an HTTP request, or a message being added to a queue.</span></span> <span data-ttu-id="a1e71-130">함수 정의의 일부로 트리거를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-130">You configure a trigger as part of the function definition.</span></span> <span data-ttu-id="a1e71-131">이 방법은 데이터가 들어오는 위치(트리거/입력 바인딩) 및 나가는 위치(출력 바인딩)를 선언할 수 있게 함으로써 코드를 단순화합니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-131">This approach simplifies your code by allowing you to declare where the data comes from (trigger/input binding) and where it goes (output binding).</span></span> <span data-ttu-id="a1e71-132">큐, Blob, 허브 등을 보기 위한 코드를 작성할 필요가 없습니다. 비즈니스 논리에 전적으로 초점을 맞출 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-132">You don't need to write code to watch queues, blobs, hubs, etc. You can focus purely on the business logic.</span></span>

### <a name="functions-can-be-used-in-traditional-compute-environments"></a><span data-ttu-id="a1e71-133">기존 계산 환경에서 함수를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-133">Functions can be used in traditional compute environments</span></span>

<span data-ttu-id="a1e71-134">함수는 서버리스 컴퓨팅의 핵심 구성 요소이지만, 모든 코드 형식을 실행하기 위한 일반 계산 플랫폼이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-134">Functions are a key component of serverless computing, but they are also a general compute platform for executing any type of code.</span></span> <span data-ttu-id="a1e71-135">앱의 요구 사항이 변경되는 경우 프로젝트를 가져와서 서버리스 이외의 환경에 배포할 수 있으므로, 유연하게 크기 조정을 관리하고, 가상 네트워크에서 실행하고, 함수를 완전히 격리할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-135">Should the needs of your app change, you can take your project and deploy it in a non-serverless environment, which gives you the flexibility to manage scaling, run on virtual networks, and even completely isolate your functions.</span></span>

## <a name="drawbacks-of-a-serverless-compute-solution"></a><span data-ttu-id="a1e71-136">서버리스 계산 솔루션의 단점</span><span class="sxs-lookup"><span data-stu-id="a1e71-136">Drawbacks of a serverless compute solution</span></span>

<span data-ttu-id="a1e71-137">서버리스 계산은 비즈니스 논리를 호스트하는 데 항상 적절한 솔루션이 되지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-137">Serverless compute will not always be the appropriate solution to hosting your business logic.</span></span> <span data-ttu-id="a1e71-138">다음은 서버리스 계산으로 서비스를 호스트하기 위한 의사 결정에 영향을 줄 수 Azure 함수의 몇 가지 특징입니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-138">Here are a few characteristics of functions that may affect your decision to host your services in serverless compute.</span></span>

### <a name="execution-time"></a><span data-ttu-id="a1e71-139">실행 시간</span><span class="sxs-lookup"><span data-stu-id="a1e71-139">Execution time</span></span>

<span data-ttu-id="a1e71-140">기본적으로 함수에는 5분의 시간 제한이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-140">By default, functions have a timeout of 5 minutes.</span></span> <span data-ttu-id="a1e71-141">이 시간 제한을 최대 10분으로 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-141">This timeout is configurable to a maximum of 10 minutes.</span></span> <span data-ttu-id="a1e71-142">실행하는 데 10분 넘게 필요한 경우 VM에서 호스트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-142">If your function requires more than 10 minutes to execute, you can host it on a VM.</span></span> <span data-ttu-id="a1e71-143">그뿐만 아니라 HTTP 요청을 통해 서비스가 시작되고 해당 값이 HTTP 응답으로 예상되는 경우 제한 시간은 2.5분으로 더 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-143">Additionally, if your service is initiated through an HTTP request and you expect that value as an HTTP response, the timeout is further restricted to 2.5 minutes.</span></span> <span data-ttu-id="a1e71-144">마지막으로 시간 제한 없이 여러 함수의 실행을 오케스트레이션할 수 있도록 하는 **지속성 함수**라는 옵션도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-144">Finally, there's also an option called **Durable Functions** that allows you to orchestrate the executions of multiple functions without any timeout.</span></span>

### <a name="execution-frequency"></a><span data-ttu-id="a1e71-145">실행 빈도</span><span class="sxs-lookup"><span data-stu-id="a1e71-145">Execution frequency</span></span>

<span data-ttu-id="a1e71-146">두 번째 특성은 실행 빈도입니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-146">The second characteristic is execution frequency.</span></span> <span data-ttu-id="a1e71-147">여러 클라이언트가 함수를 계속 실행할 것으로 예상되는 경우에는 사용을 추정하고 적절하게 함수 사용 비용을 계산하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-147">If you expect your function to be executed continuously by multiple clients, it would be prudent to estimate the usage and calculate the cost of using functions accordingly.</span></span> <span data-ttu-id="a1e71-148">VM에서 서비스를 호스트하는 것이 더 저렴할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-148">It might be cheaper to host your service on a VM.</span></span>

<span data-ttu-id="a1e71-149">크기가 조정되는 동안 10초마다 하나의 함수 앱 인스턴스만, 최대 총 200개의 인스턴스를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-149">While scaling, only one function app instance can be created every 10 seconds, for up to 200 total instances.</span></span> <span data-ttu-id="a1e71-150">각 인스턴스는 여러 동시 실행을 서비스할 수 있으므로, 단일 인스턴스가 처리할 수 있는 트래픽의 양에는 일정한 제한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a1e71-150">Keep in mind, each instance can service multiple concurrent executions, so there is no set limit on how much traffic a single instance can handle.</span></span> <span data-ttu-id="a1e71-151">서로 다른 유형의 트리거는 크기 조정 요구 사항이 서로 다르므로, 선택한 트리거를 알아보고 한도를 조사하세요.</span><span class="sxs-lookup"><span data-stu-id="a1e71-151">Different types of triggers have different scaling requirements, so research your choice of trigger and investigate its limits.</span></span>
